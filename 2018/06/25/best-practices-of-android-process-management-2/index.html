<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 如何优雅地构建易维护、可复用的 Android 业务流程(二) · Prototype Z</title><meta name="description" content="管理复杂业务流程"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="https://avatars0.githubusercontent.com/u/18300865?v=3&amp;s=40"><link rel="stylesheet" href="/css/apollo.css"><!--if theme.googlefonts--><!--    link(rel="stylesheet", href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600" type='text/css')--><!--else --><!--    link(rel="stylesheet", href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type='text/css')--></head><body><div id="mask" style="display: none;"><img id="mask-image" src="#" style=" "></div><div class="wrap"><header><a href="/" class="logo-link"><img src="https://avatars0.githubusercontent.com/u/18300865?v=3&amp;s=120"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/kuailederena" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/prototypez" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">如何优雅地构建易维护、可复用的 Android 业务流程(二)</h1><div class="post-time">Jun 25, 2018</div><div class="post-content"><p>这是关于如何在 Android 中封装业务流程经验分享的第二篇，第一篇在<a href="http://prototypez.github.io/2018/04/30/best-practices-of-android-process-management/">这里</a>。所谓 <strong>业务流程</strong> ，指的是一系列页面的集合，这些页面肩负着一个特定职责，负责和用户交互，从用户端收集信息。业务流程有时候由用户主动触发，而有时候是由于某些条件不满足而触发，当流程完成以后，有时候只是简单地回到发起流程的页面，用流程的结果更新那个页面；而有时候是继续之前 <strong>由于触发流程而中断</strong> 的操作；还有些时候是则是转入新的流程。</p>
<a id="more"></a>
<h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>在<a href="http://prototypez.github.io/2018/04/30/best-practices-of-android-process-management/">上一篇分享</a>中，我根据自己在公司项目中的实践，列举了七点流程框架应该解决的问题。同时也记录了在选型过程中调研和尝试的若干种方案，它们的优点与不足，以及最后为什么放弃的原因，这些方案分别是：</p>
<ul>
<li>简单的基于 <code>startActivityForResult</code>/<code>onActivityResult</code></li>
<li>基于 EventBus 或者其他基于事件总线的方案</li>
<li>简单的基于 <code>FLAG_ACTIVITY_CLEAR_TOP</code> 或者设置 launchMode 为 singleTop / singleTask  </li>
<li>开辟新的 Activity 任务栈</li>
</ul>
<p>上一篇分享中提出的最后一个方案 – <strong>使用 Fragment 框架封装流程</strong>，是我相对而言比较满意的方案，它并不是完美的方案，至少它没有全部解决我自己提出的对流程框架的七个问题，但是从现阶段来看，在复杂程度，易用性和可靠性上，这种方案已经足够满足我们日常开发所需，在我发现更好的方案之前，我认为还是值得介绍一下的:)</p>
<p>简单回顾一下，这种方案就是一个 Activity 对应一个流程，这个 Activity 就是这个流程对外暴露的接口，具体暴露的接口是 <code>startActivityForResult</code> 和 <code>onActivityResult</code>, 任何触发流程的位置，都只通过这两个方法，和代表流程的 Activity 进行交互。</p>
<p>流程的每一个步骤（页面），被封装为一个个 Fragment, Fragment 只和宿主 Activity 交互，通常就是把本步骤的数据传递给宿主 Activity 以及通知宿主 Activity 本步骤已做完。宿主 Activity 即流程 Activity。</p>
<p>流程 Activity 除了担当本流程对外接口任务以外，还要承担流程内部步骤间的流转，其实就是对代表步骤的 Fragment 的添加与移除。</p>
<p>以登录流程为例（包含两个步骤：用户名密码验证、需要手机验证码的两步验证）, 整个流程与流程触发点（例如首页信息流点赞操作）的交互以及流程内部 Fragment 栈如下图所示：</p>
<p><img src="/images/login-sample-5.png" alt=""></p>
<p>而流程宿主 Activity 与代表流程的每个具体步骤的 Fragment 的交互可以用下图来表示：</p>
<p><img src="/images/login-sample-4.png" alt=""></p>
<h2 id="如何优化流程与外部交互接口"><a href="#如何优化流程与外部交互接口" class="headerlink" title="如何优化流程与外部交互接口"></a>如何优化流程与外部交互接口</h2><p>上一篇分享中，最后有提到基于 <code>startActivityForResult</code> 和 <code>onActivityResult</code> 两个方法来发起流程和接收流程结果是 <strong>不优雅</strong> 的，而且这种写法也不利于流程在其他位置被复用。例如登录操作在点赞时可能被触发，在评论时也可能被触发，常规写法只会让 Activity / Fragment 过于臃肿。</p>
<p>我们希望的结果是，发起流程可以被封装为一个普通的异步操作，然后我们就可以像对待普通的异步任务那样，为这个流程指派一个观察者来监听异步结果。但是封装的难点在于我们并不容易在 <code>startActivityForResult</code> 的位置获取一个对象，这个对象可以在 <code>onActivityResult</code> 的时候获得回调，根源在于 <code>onActivityResult</code> 并不属于 Activity / Fragment 的生命周期函数，所以无论是 Google 官方的 <a href="https://developer.android.com/topic/libraries/architecture/lifecycle" target="_blank" rel="noopener">Lifecycle Component</a> 还是第三方的 <a href="https://github.com/trello/RxLifecycle" target="_blank" rel="noopener">RxLifecycle</a> 都不包含这个回调。</p>
<p>但是我们还是有机会通过别的办法在 <code>startActivityForResult</code> 的位置拿到 <code>onActivityResult</code> 这个回调的观察者。其中一种方案就是借鉴 <a href="https://github.com/bumptech/glide.git" target="_blank" rel="noopener">Glide</a> 的思想，Glide 可以为异步操作绑定 Activity 的生命周期，它的原理就是为发起请求的 Activity 添加一个 <strong>不可见的 Fragment</strong>，大家知道，Fragment 也可以发起 <code>startActivityForResult</code> 操作，并通过 <code>onActivityResult</code> 接受结果。 </p>
<p>到这里，我们的思路就清晰了。我们的 Activity 自己不需要发起 <code>startActivityForResult</code>，而是新建一个不可见的 Fragemnt ，然后把这个任务交给它，Fragment 就相当于一个观察者， Activity 持有这个 Fragment 对象，Fragment 可以在自己收到 <code>onActivityResult</code> 的时候把结果通知 Activity。</p>
<p>这种做法有两个好处：首先，</p>
<ol>
<li><p>如果我们自己创建一个观察者，那么通常会被放在全局作用空间。那么就需要仔细考虑对象生命周期绑定问题，以防止可能造成的内存泄漏。Fragment 属于 Android 框架的一部分，只要正常使用（例如不要错误使用 static 引用，谨慎使用匿名内部类），就不会造成内存泄漏。</p>
</li>
<li><p>自己创建的观察者对象，在 <strong>进程被杀死重新创建</strong> 或者 <strong>后台Activity被回收</strong> 的情况下，可能无法正常恢复，一方面可能导致无法接收到 <code>onActivityResult</code> 的结果，另一方面有可能导致应用 Crash（通常是因为空指针）。而如果我们把观察者的任务交给 Fragment，由于 Fragment 被 Activity 的 FragmentManager 管理，即使 Activity 由于系统的原因被销毁重新创建了，还是可以保证观察者自身被正确恢复，并且正常收到 <code>onActivityResult</code> 回调。</p>
</li>
</ol>
<h2 id="使用-RxJava-进行封装"><a href="#使用-RxJava-进行封装" class="headerlink" title="使用 RxJava 进行封装"></a>使用 RxJava 进行封装</h2><p>上一小节提到，我们希望可以像对待一个普通的异步任务一样，对待业务流程。对于像我们这样的已经在项目中引入 <a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="noopener">RxJava</a> 的团队来说，使用 RxJava 封装自然是首选。</p>
<p>首先，<code>onActivityResult</code> 这个回调中回传给我们的 3 个参数，我们单独封装为一个类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityResult</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> requestCode;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> resultCode;</span><br><span class="line">    <span class="keyword">private</span> Intent data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.requestCode = requestCode;</span><br><span class="line">        <span class="keyword">this</span>.resultCode = resultCode;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getters &amp; setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本文在第一节的时候提到：流程 <strong>有时候是由于某些条件不满足而触发</strong> 的，举一个简单的例子：社交 App 的点赞操作需要登录态才可以进行，那么处理点赞事件的代码很有可能是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">likeBtn.setOnClickListener(v -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (LoginInfo.isLogin()) &#123;</span><br><span class="line">        doLike();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        startLoginProcess()</span><br><span class="line">            .subscribe(<span class="keyword">this</span>::doLike);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>上面的代码中，我们假设 <code>startLoginProcess</code> 为一个封装好的登录流程，它的返回类型为 <code>Observable&lt;ActivityResult&gt;</code>。像这样的条件检测并且发起流程的类似代码很多，一个异步任务，把原本逻辑上流畅的一个代码流程给拆成两部分。为了可以让这部分更优雅，我们其实可以把 <code>LoginInfo.isLogin()</code> 为 <code>true</code> 这种情况也视为 <code>startLoginProcess</code> 这个 <code>Observable</code> 所发射的数据。到目前为止 <code>ActivityResult</code> 这个对象我们已经单独封装好了，我们可以自行实例化这个对象，无需依赖 <code>onActivityResult</code> 回调来构造这个对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Observable&lt;ActivityResult&gt; <span class="title">loginState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (LoginInfo.isLogin()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Observable.just(<span class="keyword">new</span> ActivityResult(REQUEST_CODE_LOGIN, RESULT_OK, <span class="keyword">new</span> Intent()));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> startLoginProcess();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样一来，检测用户是否登录，在 <strong>用户已经登录</strong> 和 <strong>用户一开始没登录但是通过登录流程以后登录成功</strong> 的情况下，执行点赞操作的代码就变成了下面这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">likeBtn.setOnClickListener(v -&gt; &#123;</span><br><span class="line">    loginState()</span><br><span class="line">        .subscribe(<span class="keyword">this</span>::doLike);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>虽然整体上代码量并没有变少，但是逻辑上更加清晰了，<code>loginState</code> 这个方法也更容易被其他地方所复用了。</p>
<p>接下来的部分是 承担着 <code>onActivityResult</code> 这个方法的观察者 的责任的 Fragment，根据刚刚的讨论结果，这个 Fragment 需要提供一个方法，允许除了在它自己得到 <code>onActivityResult</code> 回调时实例化一个 <code>ActivityResult</code> 这种情况以外，也可以手动插入一个 <code>ActivityResult</code> 对象，这样的封装可以在应对 <strong>条件检测 - 发起流程</strong> 这类情景时，对外部有更加简洁和一致的接口。具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityResultFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BehaviorSubject&lt;ActivityResult&gt; mActivityResultSubject = BehaviorSubject.create();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onActivityResult(requestCode, resultCode, data);</span><br><span class="line">        mActivityResultSubject.onNext(<span class="keyword">new</span> ActivityResult(requestCode, resultCode, data));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Observable&lt;ActivityResult&gt; <span class="title">getActivityResultObservable</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">        FragmentManager fragmentManager = activity.getFragmentManager();</span><br><span class="line">        ActivityResultFragment fragment = (ActivityResultFragment) fragmentManager.findFragmentByTag(</span><br><span class="line">                ActivityResultFragment.class.getCanonicalName());</span><br><span class="line">        <span class="keyword">if</span> (fragment == <span class="keyword">null</span>) &#123;</span><br><span class="line">            fragment = <span class="keyword">new</span> ActivityResultFragment();</span><br><span class="line">            fragmentManager.beginTransaction()</span><br><span class="line">                    .add(fragment, ActivityResultFragment.class.getCanonicalName())</span><br><span class="line">                    .commit();</span><br><span class="line">            fragmentManager.executePendingTransactions();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fragment.mActivityResultSubject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startActivityForResult</span><span class="params">(Activity activity, Intent intent, <span class="keyword">int</span> requestCode)</span> </span>&#123;</span><br><span class="line">        FragmentManager fragmentManager = activity.getFragmentManager();</span><br><span class="line">        ActivityResultFragment fragment = (ActivityResultFragment) fragmentManager.findFragmentByTag(</span><br><span class="line">                ActivityResultFragment.class.getCanonicalName());</span><br><span class="line">        <span class="keyword">if</span> (fragment == <span class="keyword">null</span>) &#123;</span><br><span class="line">            fragment = <span class="keyword">new</span> ActivityResultFragment();</span><br><span class="line">            fragmentManager.beginTransaction()</span><br><span class="line">                    .add(fragment, ActivityResultFragment.class.getCanonicalName())</span><br><span class="line">                    .commit();</span><br><span class="line">            fragmentManager.executePendingTransactions();</span><br><span class="line">        &#125;</span><br><span class="line">        fragment.startActivityForResult(intent, requestCode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertActivityResult</span><span class="params">(Activity activity, ActivityResult activityResult)</span> </span>&#123;</span><br><span class="line">        FragmentManager fragmentManager = activity.getFragmentManager();</span><br><span class="line">        ActivityResultFragment fragment= (ActivityResultFragment) fragmentManager.findFragmentByTag(</span><br><span class="line">                ActivityResultFragment.class.getCanonicalName());</span><br><span class="line">        <span class="keyword">if</span> (fragment == <span class="keyword">null</span>) &#123;</span><br><span class="line">            fragment = <span class="keyword">new</span> ActivityResultFragment();</span><br><span class="line">            fragmentManager.beginTransaction()</span><br><span class="line">                    .add(fragment, ActivityResultFragment.class.getCanonicalName())</span><br><span class="line">                    .commit();</span><br><span class="line">            fragmentManager.executePendingTransactions();</span><br><span class="line">        &#125;</span><br><span class="line">        fragment.mActivityResultSubject.onNext(activityResult);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>ActivityResultFragment</code> 这个类中：</p>
<ol>
<li><p><code>mActivityResultSubject</code> 即为发射 <code>ActivityResult</code> 的 Observable ；</p>
</li>
<li><p><code>getActivityResultObservable</code> 这个方法是用于在 Activity 中获取不可见 Fragment 对应的 <code>Observable&lt;ActivityResult&gt;</code>，借鉴了 Glide 的思想；</p>
</li>
<li><p><code>onActivityResult</code> 这个方法里，Fragment 把自己接收到的数据封装为 <code>ActivityResult</code> 传递给 <code>mActivityResultSubject</code>；</p>
</li>
<li><p><code>startActivityForResult</code> 这个方法是用来被 Activity 调用的，Activity 把本来应该由自己发起的 <code>startActivityForResult</code> 交给由这个 Fragment 来发起；</p>
</li>
<li><p><code>insertActivityResult</code> 这个方法的作用前面解释过了，是为了给调用流程的调用者，提供一致的接口，主要优化 <strong>条件检测 - 发起流程</strong> 这种情景。</p>
</li>
</ol>
<h2 id="可复用流程的封装"><a href="#可复用流程的封装" class="headerlink" title="可复用流程的封装"></a>可复用流程的封装</h2><p>到目前为止，基于 RxJava，需要封装流程所需的基础设施已经准备完毕。我们来尝试封装一个流程，以登录流程为例，按上一篇讨论的结果，登录流程可能包含多个页面（用户名、密码验证，手机验证码两步验证等），也可能有子流程（忘记密码），但是对于“登录”这个流程，它对外只暴露一个代表它这个流程的 Activity，无论它内部跳转多么复杂，外部与这个登录流程交互也非常简单，只需要通过 <code>startActivityForResult</code> 和 <code>onActivityResult</code> 这两个方法。而这两个方法在上一节已经可以被很方便的封装，我们以登录流程为例，假设登录流程只对外暴露 <code>LoginActivity</code> 这一个 Activity，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// your other code</span></span><br><span class="line"></span><br><span class="line">        loginBtn.setOnClickListener(v -&gt; &#123;</span><br><span class="line">            <span class="comment">// 简单起见，略去请求部分，直接登录成功</span></span><br><span class="line">            <span class="keyword">this</span>.setResult(RESULT_OK);</span><br><span class="line">            finish();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Observable&lt;ActivityResult&gt; <span class="title">loginState</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (LoginInfo.isLogin()) &#123;</span><br><span class="line">            ActivityResultFragment.insertActivityResult(</span><br><span class="line">                activity,</span><br><span class="line">                <span class="keyword">new</span> ActivityResult(REQUEST_CODE_LOGIN, RESULT_OK, <span class="keyword">new</span> Intent())</span><br><span class="line">            );</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Intent intent = <span class="keyword">new</span> Intent(activity, LoginActivity.class);</span><br><span class="line">            ActivityResultFragment.startActivityForResult(activity, intent, REQUEST_CODE_LOGIN);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ActivityResultFragment.getActivityResultObservable(activity)</span><br><span class="line">            .filter(ar -&gt; ar.getRequestCode() == REQUEST_CODE_LOGIN)</span><br><span class="line">            .filter(ar -&gt; ar.getResultCode() == RESULT_OK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 Activity 对外提供一个静态的 <code>loginState</code> 方法，返回类型为 <code>Observable&lt;ActivityResult&gt;</code>，在已经登录的情况下，Observable 会立即发送一个 <code>ActivityResult</code> 表示登录成功，在非登录态下, 会唤起登录流程，如果登录流程最后的结果是登录成功，Observable 也会发送一个 <code>ActivityResult</code> 表示登录成功，所以凡是使用到这个登录流程的地方，对这个登录流程的调用，应该如下代码所示(仍然以点赞操作为例)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">likeBtn.setOnClickListener(v -&gt; &#123;</span><br><span class="line">    LoginActivity.loginState(<span class="keyword">this</span>)</span><br><span class="line">        .subscribe(<span class="keyword">this</span>::doLike);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>原先需要书写复杂的 <code>startActivityForResult</code> 和 <code>onActivityResult</code> 两个方法，才能完成和登录流程交互，而且还需要在发起流程前先确认是否当前已经是登录态，现在只需要一行 <code>LoginActivity.loginState()</code>, 然后指定一个 Observer 即可达到一样的效果，更重要的是，写法变简单了以后，整个登录流程变得非常容易复用，任何需要检查登录态然后再做操作的地方，都只需要这一行代码即可完成登录态检测，实现了 <strong>流程的高度可复用</strong>。 </p>
<p>这种写法可以在流程完成以后，继续之前的操作（例如本例中点赞），不需要用户重新进行一遍先前被流程所打断的操作（例如本例中的点赞操作）。但是细心的你可能并不这么认为，因为上面的代码本质上是有问题的，问题在于在上面 <code>LoginActivity.loginState()</code> 的调用在 <code>likeBtn.setOnClickListener</code> 的内部回调，那么考虑极端情况，如果登录流程被唤起，而发起登录流程的 Activity 不幸被系统回收，那么当登录流程做完回到的发起登录流程的 Activity 将会是系统重新创建的 Activity，这个全新的 Activity 是没有执行过 <code>likeBtn.setOnClickListener</code> 的内部回调的任何代码的，所以 <code>.subscribe()</code> 方法指定的观察者不会受到任何回调，<code>this::doLike</code> 不会被执行。</p>
<p>为了可以让封装的流程兼容这种情况，可以采用这种方案：修改 <code>loginState</code> 方法，使其返回 <a href="http://reactivex.io/RxJava/javadoc/io/reactivex/ObservableTransformer.html" target="_blank" rel="noopener">ObservableTransformer</a>, 我们重命名 <code>loginState</code> 方法为 <code>ensureLogin</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ObservableTransformer&lt;T, ActivityResult&gt; <span class="title">ensureLogin</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> upstream -&gt; &#123;</span><br><span class="line">        Observable&lt;ActivityResult&gt; loginOkResult = ActivityResultFragment.getActivityResultObservable(activity)</span><br><span class="line">            .filter(ar -&gt; ar.getRequestCode() == REQUEST_CODE_LOGIN)</span><br><span class="line">            .filter(ar -&gt; ar.getResultCode() == RESULT_OK);</span><br><span class="line"></span><br><span class="line">        upstream.subscribe(t -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (LoginInfo.isLogin()) &#123;</span><br><span class="line">                ActivityResultFragment.insertActivityResult(</span><br><span class="line">                    activity,</span><br><span class="line">                    <span class="keyword">new</span> ActivityResult(REQUEST_CODE_LOGIN, RESULT_OK, <span class="keyword">new</span> Intent())</span><br><span class="line">                );</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Intent intent = <span class="keyword">new</span> Intent(activity, LoginActivity.class);</span><br><span class="line">                ActivityResultFragment.startActivityForResult(activity, intent, REQUEST_CODE_LOGIN);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> loginOkResult;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果您之前没有接触过 <code>ObservableTransformer</code>, 这里做一个简单介绍，它通常和 <code>compose</code> 操作符一起使用，用来把一个 <code>Observable</code> 进行加工、修饰，甚至替换为另一个 <code>Observable</code>。</p>
</blockquote>
<p>登录流程的封装，现在对外体现为 <code>ensureLogin</code> 这一个方法，那么其它代码如何调用这个登录流程呢，还是以点赞操作为例，现在的代码应该是这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RxView.clicks(likeBtn)</span><br><span class="line">    .compose(LoginActivity.ensureLogin(<span class="keyword">this</span>))</span><br><span class="line">    .subscribe(<span class="keyword">this</span>::doLike);</span><br></pre></td></tr></table></figure>
<p>这里的 <code>RxView.clicks</code> 使用了 <a href="https://github.com/JakeWharton/RxBinding" target="_blank" rel="noopener">RxBinding</a> 这个开源库，用于把 View 的事件，转化为 <code>Observable</code>，当然其实你也可以自己封装。改完这种写法以后，刚刚提到的极端情况下也可以正常工作了，即使发起流程的页面在流程被唤起后被系统回收，在流程完成以后回到发起页，发起页被重新创建了，发起页的 <code>Observer</code> 依然可以正常收到流程结果，之前被中端的操作得以继续执行。</p>
<p>现在我们可以稍微总结一下，根据上一篇和本篇提出建议，如何封装一个业务流程：</p>
<ol>
<li>一个业务流程对应一个 Activity，这个 Activity 作为对外的接口以及流程内部步骤的调度者；</li>
<li>一个流程内部的一个步骤对应一个 Fragment，这个 Fragment 只负责完成自己的任务以及把自己的数据反馈给 Activity；</li>
<li>流程对外暴露的接口应该封装为一个 <code>ObservableTransformer</code>，流程发起者应该提供发起流程的 <code>Observable</code>（例如以 <code>RxView.clicks</code> 的形式提供），两者通过 <code>compose</code> 操作符关联起来。</li>
</ol>
<p>这是我个人实践出的一套封装流程的经验，它并不是完美的方案，但是在可靠性、可复用程度、接口简单程度上已经足以胜任我个人的日常开发，所以才有了这两篇分享。</p>
<p>我们已经封装了一个最简单的流程 – 登录流程，但是实际项目中往往会遇到更严峻的挑战，例如流程组合与流程嵌套。</p>
<h2 id="复杂流程实践：流程组合"><a href="#复杂流程实践：流程组合" class="headerlink" title="复杂流程实践：流程组合"></a>复杂流程实践：流程组合</h2><p>举例：某款基金销售 App，在用户点击购买基金时，可能存在如下图流程：<br><img src="/images/process-combine-1.png" alt=""></p>
<p>可用从上图中看出，某个未登录用户想要购买一款基金的最长路径包含：<strong>登录 - 绑卡 - 风险测评 - 投资者适当性管理</strong> 这几个步骤。但是，并不是所有用户都要经历所有这些步骤，例如，如果用户已登录并且已做过风险测评，那这个用户只需要再做 <strong>绑卡 - 适当性管理</strong> 这两步就可以了。</p>
<p>这样的一个需求，如果用传统的写法来写，可以预见肯定会在 click 事件处理的地方罗列很多 <code>if - else</code> ：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 设置点击事件处理函数</span></span><br><span class="line">buyFundBtn.setOnClickListener(v -&gt; handleBuyFund());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 处理结果</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (requestCode) &#123;</span><br><span class="line">        <span class="keyword">case</span> REQUEST_LOGIN:</span><br><span class="line">        <span class="keyword">case</span> REQUEST_ADD_BANKCARD:</span><br><span class="line">        <span class="keyword">case</span> REQUEST_RISK_TEST:</span><br><span class="line">        <span class="keyword">case</span> REQUEST_INVESTMNET_PROMPT:</span><br><span class="line">            <span class="keyword">if</span> (resultCode == RESULT_OK) handleBuyFund();  </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleBuyFund</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否已登录</span></span><br><span class="line">    <span class="keyword">if</span> (!isLogin()) &#123;</span><br><span class="line">        startLogin();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否已绑卡</span></span><br><span class="line">    <span class="keyword">if</span> (!hasBankcard()) &#123;</span><br><span class="line">        startAddBankcard();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否已做风险测试</span></span><br><span class="line">    <span class="keyword">if</span> (!isRisktestDone()) &#123;</span><br><span class="line">        startRiskTest();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否需要按照投资者适当性管理规定，给予用户必要提示</span></span><br><span class="line">    <span class="keyword">if</span> (investmentPrompt()) &#123;</span><br><span class="line">        startInvestmentPrompt();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    startBuyFundActivity();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面这种写法一方面代码比较长，另一方面，流程发起和结果处理分散在两处，代码较为不易维护。我们分析一下，整个大的流程是几个小流程的组合，我们可以把上面的图上的流程换一种画法：</p>
<p><img src="/images/process-combine-2.png" alt=""></p>
<p>按照上文的思想，我们令每个流程对外暴露一个 Activity，并且已经使用 RxJava <code>ObservableTransformer</code> 封装好，那么前面复杂的代码可以简化为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RxView.clicks(buyFundBtn)</span><br><span class="line">    <span class="comment">// 确保未登录情况下，发起登录流程，已登录情况下自动流转至下一个流程</span></span><br><span class="line">    .compose(ActivityLogin.ensureLogin(<span class="keyword">this</span>))</span><br><span class="line">    <span class="comment">// 确保未绑卡情况下，发起绑卡流程，已绑卡情况下自动流转至下一个流程</span></span><br><span class="line">    .compose(ActivityBankcardManage.ensureHavingBankcard(<span class="keyword">this</span>))</span><br><span class="line">    <span class="comment">// 确保未风险测评情况下，发起风险测评流程，已测评情况下自动流转至下一个流程</span></span><br><span class="line">    .compose(ActivityRiskTest.ensureRiskTestDone(<span class="keyword">this</span>))</span><br><span class="line">    <span class="comment">// 确保需要适当性提示情况下，发起适当性提示，已提示或不需要提示情况下自动流转至下一个流程</span></span><br><span class="line">    .compose(ActivityInvestmentPrompt.ensureInvestmentPromptOk(<span class="keyword">this</span>))</span><br><span class="line">    <span class="comment">// 所有条件都满足，进入购买基金页</span></span><br><span class="line">    .subscribe(v -&gt; startBuyFundActivity(<span class="keyword">this</span>));</span><br></pre></td></tr></table></figure>
<p>通过 RxJava 的良好封装，我们做到了可以用更少的代码来表达更复杂的逻辑。上面的例子中的 4 个被组合的流程，它们有一个共同的特点，就是彼此独立，互相不依赖其它剩余流程的结果，现实中，我们可能会遇到这样的情况: B 流程启动，需要依赖 A 流程完成的结果，为了能满足这种情况，我们只需要对上面的封装稍作修改。</p>
<p>假设绑卡流程需要依赖登录流程完成后的用户信息，那么首先，在登录流程结束调用 <code>setResult</code> 的位置, 传递用户信息：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setResult(</span><br><span class="line">    RESULT_OK, </span><br><span class="line">    IntentBuilder.newInstance().putExtra(<span class="string">"user"</span>, user).build()</span><br><span class="line">);</span><br><span class="line">finish();</span><br></pre></td></tr></table></figure></p>
<p>然后，修改 <code>ensureLogin</code> 方法，使经过 <code>ObservableTransformer</code> 处理后，返回的新的 <code>Observable</code> 由发射 <code>ActivityResult</code> 改为发射 <code>User</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ObservableTransformer&lt;T, User&gt; <span class="title">ensureLogin</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> upstream -&gt; &#123;</span><br><span class="line">        Observable&lt;ActivityResult&gt; loginOkResult = ActivityResultFragment.getActivityResultObservable(activity)</span><br><span class="line">            .filter(ar -&gt; ar.getRequestCode() == REQUEST_CODE_LOGIN)</span><br><span class="line">            .filter(ar -&gt; ar.getResultCode() == RESULT_OK)</span><br><span class="line">            .map(ar -&gt; (User)ar.getData.getParcelableExtra(<span class="string">"user"</span>));</span><br><span class="line"></span><br><span class="line">        upstream.subscribe(t -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (LoginInfo.isLogin()) &#123;</span><br><span class="line">                ActivityResultFragment.insertActivityResult(</span><br><span class="line">                    activity,</span><br><span class="line">                    <span class="keyword">new</span> ActivityResult(</span><br><span class="line">                        REQUEST_CODE_LOGIN, </span><br><span class="line">                        RESULT_OK, </span><br><span class="line">                        IntentBuilder.newInstance().putExtra(<span class="string">"user"</span>, LoginInfo.getUser()).build()</span><br><span class="line">                    )</span><br><span class="line">                );</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Intent intent = <span class="keyword">new</span> Intent(activity, LoginActivity.class);</span><br><span class="line">                ActivityResultFragment.startActivityForResult(activity, intent, REQUEST_CODE_LOGIN);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> loginOkResult;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>与此同时，原来的 <code>ensureHavingBankcard</code> 方法的 <code>ObservableTransformer</code> 方法接受的 Observable 原来是任意类型 T 的，由于我们现在规定，绑卡流程需要依赖登录流程的结果 User ，所以我们把 T 类型，改为 User 类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ObservableTransformer&lt;User, ActivityResult&gt; <span class="title">ensureHavingBankcard</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> upstream -&gt; &#123;</span><br><span class="line">        Observable&lt;ActivityResult&gt; bankcardOk = ActivityResultFragment.getActivityResultObservable(activity)</span><br><span class="line">            .filter(ar -&gt; ar.getRequestCode() == REQUEST_ADD_BANKCARD)</span><br><span class="line">            .filter(ar -&gt; ar.getResultCode() == RESULT_OK);</span><br><span class="line"></span><br><span class="line">        upstream.subscribe(user -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (getBankcardNum() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ActivityResultFragment.insertActivityResult(</span><br><span class="line">                    activity,</span><br><span class="line">                    <span class="keyword">new</span> ActivityResult(</span><br><span class="line">                        REQUEST_ADD_BANKCARD, </span><br><span class="line">                        RESULT_OK, </span><br><span class="line">                        <span class="keyword">new</span> Intent()</span><br><span class="line">                    )</span><br><span class="line">                );</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Intent intent = <span class="keyword">new</span> Intent(activity, AddBankcardActivity.class);</span><br><span class="line">                intent.putExtra(<span class="string">"user"</span>, user);</span><br><span class="line">                ActivityResultFragment.startActivityForResult(activity, intent, REQUEST_ADD_BANKCARD);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bankcardOk;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，这两个流程之间就有了依赖关系，绑卡依赖登录流程返回的结果，但是组合这两个流程的写法还是不会有任何改变：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RxView.clicks(someBtn)</span><br><span class="line">    .compose(ActivityLogin.ensureLogin(<span class="keyword">this</span>))</span><br><span class="line">    .compose(ActivityBankcardManage.ensureHavingBankcard(<span class="keyword">this</span>))</span><br><span class="line">    .subscribe(v -&gt; doSomething());</span><br></pre></td></tr></table></figure>
<p>除此以外，绑卡流程还是可复用的，它是依赖可以返回 User 的流程的，所以只要是其他可以返回 User 作为结果的流程，都可以与绑卡流程组合。</p>
<h2 id="复杂流程实践：流程嵌套"><a href="#复杂流程实践：流程嵌套" class="headerlink" title="复杂流程实践：流程嵌套"></a>复杂流程实践：流程嵌套</h2><p>举例：登录流程中的登录页面，除了可以选择用户名密码登录外，往往还提供其他选项，最典型的就是注册和忘记密码两个功能：</p>
<p><img src="/images/process-insert-1.png" alt=""></p>
<p>从直觉上，我们肯定是认为注册和忘记密码应该是不属于登录这个流程的，它们是相对独立的两个流程，也就是说在登录这流程内部，嵌入了其它的流程，我把这种情况称之为流程的嵌套。</p>
<p>按照同样的套路，我们应该先把注册、忘记密码这两个流程使用 <code>ObservableTransformer</code> 进行封装，然后我们把上图流程按照本文思想整理一下，如下：</p>
<p><img src="/images/process-insert-2.png" alt=""></p>
<p>可以看到，现在的区别是，发起流程的地方不再是一个普通的 Activity，而是另一个流程中的某个步骤，按照先前的讨论，流程中的步骤是由 Fragment 承载的。所以这里有两种处理方法，一种是 Fragment 把发起流程的任务交给宿主 Activity，由宿主 Activity 分配给属于它的“看不见的 Fragment” 去发起流程并处理结果，另一种是直接由该 Fragmnet 发起流程，由于 Fragment 也有属于它自己的 ChildFragmentManager，所以只需要对“<strong>使用 RxJava 进行封装</strong>”这一节中的相关方法做一些修改即可支持由 Fragment 内部发起流程，具体修改内容为把 <code>activity.getFragmentManager()</code> 改为 <code>fragment.getChildFragmentManager()</code> 即可。</p>
<p>在具体应用中，本人使用的是后一种，即 <strong>直接由 Fragment 发起流程</strong>，因为被嵌套的流程往往和主流程有关联，即嵌套流程的结果有可能改变主流程的流转分支，所以直接由 Fragment 发起流程并处理结果比较方便一点，如果交给宿主 Activity 可能需要额外多写一些代码进行 Activity - Fragment 的通信才能实现相同效果。</p>
<p>首先，在没有嵌套流程的情况下，登录流程的第一个步骤登录步骤（用户名、密码验证），代码应该如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    <span class="comment">// UI references.</span></span><br><span class="line">    <span class="keyword">private</span> EditText mPhoneView;</span><br><span class="line">    <span class="keyword">private</span> EditText mPasswordView;</span><br><span class="line"></span><br><span class="line">    LoginCallback mCallback;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        View view = inflater.inflate(R.layout.fragment_login_by_pwd, container, <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// Set up the login form.</span></span><br><span class="line">        mPhoneView = view.findViewById(R.id.phone);</span><br><span class="line">        mPasswordView = view.findViewById(R.id.password);</span><br><span class="line"></span><br><span class="line">        Button signInButton = view.findViewById(R.id.sign_in);</span><br><span class="line">        signInButton.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">                String phone = mPhoneView.getText().toString();</span><br><span class="line">                String pwd = mPasswordView.getText().toString();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// mock login ok</span></span><br><span class="line">                    mCallback.onLoginOk(<span class="keyword">true</span>, <span class="keyword">new</span> User(</span><br><span class="line">                            UUID.randomUUID().toString(),</span><br><span class="line">                            <span class="string">"Jack"</span>,</span><br><span class="line">                            mPhoneView.getText().toString()</span><br><span class="line">                    ));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLoginCallback</span><span class="params">(LoginCallback callback)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mCallback = callback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LoginCallback</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onLoginOk</span><span class="params">(<span class="keyword">boolean</span> needSmsVerify, User user)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，<code>LoginCallback</code> 这个接口作用是，登录这个步骤，收集完信息，与服务器交互完毕后，把结果回传给宿主 Activity，由 Activity 决定后续步骤的流转。上面的例子中做了一部分简化，在 <code>onClick</code> 处理函数里没有发起和服务端的交互，而是直接 Mock 了一个请求成功的结果。</p>
<p>现在的需求是，在登录这个步骤里，嵌入两个步骤：</p>
<ol>
<li>一个是注册流程，而且注册成功后直接视为登录成功，不需要再走剩余的登录流程步骤；</li>
<li>另一个是忘记密码流程，忘记密码流程本质是重置密码，但是即使密码重置成功还是需要用户使用新密码登录，不会直接在重置密码后自动登录。</li>
</ol>
<p>根据需求，我们在上述代码中加入嵌入这两个流程的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    View view = inflater.inflate(R.layout.fragment_login_by_pwd, container, <span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">// Set up the login form.</span></span><br><span class="line">    mPhoneView = view.findViewById(R.id.phone);</span><br><span class="line">    mPasswordView = view.findViewById(R.id.password);</span><br><span class="line"></span><br><span class="line">    Button signInButton = view.findViewById(R.id.sign_in);</span><br><span class="line">    Button mPwdResetBtn = view.findViewById(R.id.pwd_reset);</span><br><span class="line">    Button mRegisterBtn = view.findViewById(R.id.register);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接登录</span></span><br><span class="line">    signInButton.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">            String phone = mPhoneView.getText().toString();</span><br><span class="line">            String pwd = mPasswordView.getText().toString();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// mock login ok</span></span><br><span class="line">                mCallback.onLoginOk(<span class="keyword">true</span>, <span class="keyword">new</span> User(</span><br><span class="line">                        UUID.randomUUID().toString(),</span><br><span class="line">                        <span class="string">"Jack"</span>,</span><br><span class="line">                        mPhoneView.getText().toString()</span><br><span class="line">                ));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发起注册流程</span></span><br><span class="line">    RxView.clicks(mRegisterBtn)</span><br><span class="line">        .compose(RegisterActivity.startRegister(<span class="keyword">this</span>))</span><br><span class="line">        .subscribe(user -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mCallback.onRegisterOk(user);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发起忘记密码流程</span></span><br><span class="line">    RxView.clicks(mPwdResetBtn)</span><br><span class="line">        .compose(PwdResetActivity.startPwdReset(<span class="keyword">this</span>))</span><br><span class="line">        .subscribe();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> view;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LoginCallback</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onLoginOk</span><span class="params">(<span class="keyword">boolean</span> needSmsVerify, User user)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onRegisterOk</span><span class="params">(User user)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码里，<code>RegisterActivity.startRegister</code> 和 <code>PwdResetActivity.startPwdReset</code> 两个方法即为使用了 <code>ObservableTransformer</code> 封装的注册流程和忘记密码流程。同时可以看到，<code>LoginCallback</code> 这个接口里多了一个方法 <code>onRegisterOk</code>，也就是说登录这个步骤不再只有 <code>onLoginOk</code> 这一种情况通知宿主 Activity 了，在内嵌注册流程成功的情况下，也可以通知宿主 Activity，然后让宿主 Activity 决定后续流转，当然这种情况，根据需求注册成功也是属于登录成功的一种，宿主 Activity 通过 <code>setResult</code> 方法把整个登录流程的状态标记为登录成功，<code>finish</code> 自己，同时把用户信息传递给发起登录流程的地方。</p>
<p>但是为什么内嵌的注册流程需要把流程的结果回传给登录流程的宿主 Activity，而内嵌的忘记密码流程没有设置一个类似的方法回调登录流程的宿主 Activity 呢？因为注册成功这件事影响了登录流程的走向（注册成功直接视为登录成功，登录流程状态置为成功，并通知发起登录流程的地方本次登录结果为成功），而忘记密码流程最后的重置密码成功并不影响登录流程走向（即使重置密码成功依然需要在登录界面使用新密码登录）。</p>
<p>按照上面的分析，登录流程的宿主 Activity，负责分发流程步骤的逻辑的相关代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">// 用户名密码验证步骤</span></span><br><span class="line">        loginFragment.setLoginCallback(<span class="keyword">new</span> LoginFragment.LoginCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLoginOk</span><span class="params">(<span class="keyword">boolean</span> needSmsVerify, User user)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 用户名密码验证成功</span></span><br><span class="line">                <span class="keyword">if</span> (needSmsVerify) &#123;</span><br><span class="line">                    <span class="comment">// 需要短信验证码的两步验证</span></span><br><span class="line">                    push(loginBySmsFragment);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 登录成功</span></span><br><span class="line">                    setResult(</span><br><span class="line">                        RESULT_OK, </span><br><span class="line">                        IntentBuilder.newInstance().putExtra(<span class="string">"user"</span>, user).build()</span><br><span class="line">                    );</span><br><span class="line">                    finish();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRegisterOk</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 注册成功, 直接登录</span></span><br><span class="line">                setResult(</span><br><span class="line">                    RESULT_OK, </span><br><span class="line">                    IntentBuilder.newInstance().putExtra(<span class="string">"user"</span>, user).build()</span><br><span class="line">                );</span><br><span class="line">                finish();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 短信验证码两步验证步骤</span></span><br><span class="line">        loginBySmsFragment.setSmsLoginCallback(<span class="keyword">new</span> LoginBySmsFragment.LoginBySmsCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSmsVerifyOk</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 短信验证成功</span></span><br><span class="line">                setResult(</span><br><span class="line">                    RESULT_OK, </span><br><span class="line">                    IntentBuilder.newInstance().putExtra(<span class="string">"user"</span>, user).build()</span><br><span class="line">                );</span><br><span class="line">                finish();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，即使是流程嵌套的情况下，使用 RxJava 封装的流程依然不会使流程跳转的代码显得十分混乱，这点十分可贵，因为这意味着今后流程相关代码不会成为项目中难以维护的模块，而是清晰且高内聚的。</p>
<h2 id="流程上下文保存"><a href="#流程上下文保存" class="headerlink" title="流程上下文保存"></a>流程上下文保存</h2><p>到目前为止，我们还剩最后一个问题需要解决，即涉及流程的相关上下文保存。具体包含两部分，一是流程触发点，发起流程的位置，需要对发起流程前的上下文进行保存，另一部分是流程中间步骤的结果，也需要进行保存。</p>
<p><strong>1. 流程中间步骤的结果的保存</strong></p>
<p>要对流程中间步骤的结果进行保存是因为，按照我们前面的讨论，流程中每个步骤（即Fragment），会和用户交互，然后把该步骤的结果传递给宿主 Activity，那么假设流程没有做完，并且该步骤的结果可能会被后续步骤使用，那么宿主 Activity 是有必要保存这个结果的，那么通常这个结果会以这个 Activity 的成员变量的形式被保存，问题在于 Activity 一旦被置于后台，就随时可能被系统回收，此时可能流程并没有做完，如果没有对 Activity 的成员变量做保存和恢复处理，当下次 Activity 回到前台以后，这个流程的状态就处于不确定状态了，甚至可能崩溃。</p>
<p>解决的方案很显然，继承 Activity 的 <code>onSaveInstanceState</code> 和 <code>onRestoreInstanceState</code>（或者 <code>onCreate</code>） 这两个方法，在这两个方法内部实现变量的保存与恢复操作。如果你觉得实现这两个方法会使你的代码非常丑陋，那么我推荐你使用 <a href="https://github.com/PrototypeZ/SaveState" target="_blank" rel="noopener">SaveState</a> 这个工具，使用它，你只需要在需要保存和恢复的成员变量上标记一个 <code>@AutoRestore</code> 注解，框架就会自动帮你保存和恢复成员变量，你不需要写任何额外的代码。</p>
<p><strong>2. 发起流程前的上下文的保存</strong></p>
<p>和 <strong>1</strong> 的原因类似，流程一旦被唤起，发起流程的 Activity 就处于后台状态，这是一种可能被系统回收的状态。举个例子, 有一个理财产品列表页，用户未登录状态，现在要求用户点击任何一个理财产品，先把用户带到登录界面，待登录流程完成后，把用户带到具体的理财产品购买页。列表的点击事件设置一般分两种，一是为列表中每个 Item 设置一个点击处理函数，另一种是为所有 Item 设置同一个点击处理函数。以给列表所有 Item 设置同一个点击处理函数为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 所有 Item 的点击事件对应的 Observable，其发射的元素为点击位置</span></span><br><span class="line">Observable&lt;Integer&gt; itemClicks = ...</span><br><span class="line"></span><br><span class="line">itemClicks</span><br><span class="line">    .compose(LoginActivity.ensureLogin(activity))</span><br><span class="line">    .subscribe(<span class="comment">/** 不知道怎么写 **/</span>);</span><br></pre></td></tr></table></figure>
<p><code>subscribe</code> 里面的观察者不知道怎么写了是因为 <code>LoginActivity.ensureLogin</code> 这个 <code>ObservableTransformer</code> 会把 <code>Observable&lt;T&gt;</code> 转为 <code>Observable&lt;ActivityResult&gt;</code>, 所以观察者里只知道登录成功了，不知道最初是点击哪个理财产品触发的登录操作，所以不知道应该如何去启动购买页面。</p>
<p>我们遇到的困境是当流程完成以后，我们不知道发起流程前的上下文是什么，导致我们无法在观察者里做正确的后续逻辑。一种直观的解决方案就是，我们把发起流程时的上下文数据打包进 <code>startActivityForResult</code> 的 Intent 里面，用一个保留的 Key 值去存储，同时确保流程完成时， <code>setResult</code> 调用时，会把刚刚流程传入的上下文数据，同样以一个保留的 Key 值回传给发起流程的地方。</p>
<p>如果这样处理以后，我们回过头看刚才的情况，我们再实现一个 <code>LoginActivity.ensureLoginWithContext</code> 方法，它的返回值为 <code>ObservableTransformer&lt;Bundle, Bundle&gt;</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ObservableTransformer&lt;Bundle, Bundle&gt; <span class="title">ensureLoginWithContext</span><span class="params">(AppCompatActivity activity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> upstream -&gt; &#123;</span><br><span class="line">        upstream.subscribe(contextData -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (LoginInfo.isLogin()) &#123;</span><br><span class="line">                ActivityResultFragment.insertActivityResult(</span><br><span class="line">                    activity,</span><br><span class="line">                    <span class="keyword">new</span> ActivityResult(REQUEST_LOGIN, RESULT_OK, <span class="keyword">null</span>, contextData)</span><br><span class="line">                );</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Intent intent = <span class="keyword">new</span> Intent(activity, LoginActivity.class);</span><br><span class="line">                ActivityResultFragment.startActivityForResult(activity, intent, REQUEST_LOGIN, contextData);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> ActivityResultFragment.getActivityResultObservable(activity)</span><br><span class="line">                .filter(ar -&gt; ar.getRequestCode() == REQUEST_LOGIN)</span><br><span class="line">                .filter(ar -&gt; ar.getResultCode() == RESULT_OK)</span><br><span class="line">                .map(ActivityResult::getRequestContextData);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中的 <code>ensureLoginWithContext</code> 和原先的 <code>ensureLogin</code> 方法相比，除了返回值的泛型类型不同以外，在内部实现里，调用的 <code>ActivityResult</code> 的构造方法以及 <code>startActivityForResult</code> 方法和原先的版本比都多了一个 <code>Bundle</code> 类型的 <code>contextData</code> 参数，这个参数即为需要保存的流程发起前的上下文。最后看整个方法的 return 语句，多了一个 <code>map</code> 操作符，用来把 <code>ActivityResult</code> 里保存的流程的上下文重新取出来。这里的逻辑就是刚刚提到的：在流程发起前，将流程发起前的上下文信息通过 <code>Bundle</code> 传递给流程，最后流程结束时再原封不动返回给流程发起的地方，以便流程发起点可以知晓它发起流程前的状态。这几个方法的具体实现可以参考 <a href="https://github.com/PrototypeZ/Sq" target="_blank" rel="noopener">Sq</a> 这个框架。</p>
<p>在经过这样处理以后，列表 Item 的点击事件发起登录流程的代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">itemClicks</span><br><span class="line">        .map(index -&gt; BundleBuilder.newInstance().putInt(<span class="string">"index"</span>, index).build())</span><br><span class="line">        .compose(LoginActivity.ensureLoginWithContext(<span class="keyword">this</span>))</span><br><span class="line">        .map(bundle -&gt; bundle.getInt(<span class="string">"index"</span>))</span><br><span class="line">        .subscribe(index -&gt; &#123;</span><br><span class="line">            <span class="comment">// modification of item in position $index</span></span><br><span class="line">            adapter.notifyItemChanged(index);</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></p>
<p>在 <code>compose</code> 操作符前后，分别多了一个 <code>map</code> 操作符，分别负责把上下文打包以及从流程结果中把原来的上下文解包取出来。</p>
<p>流程上下文的保存还有一个注意点，就是流程在结束时，即调用 <code>setResult</code> 时，需要保证把先前传入的的上下文再塞回去到结果里去，只有做到了这点，上面的代码才是有效的，这些工作如果总是手动来做会很繁琐，您可以选择自己封装，或者直接使用下一节介绍的开箱即用的工具。</p>
<h2 id="如何快速使用"><a href="#如何快速使用" class="headerlink" title="如何快速使用"></a>如何快速使用</h2><p>到这里为止，对于封装业务流程相关所有经验分享已经介绍完毕，如果您看到这里，对于本文以及本文的上一篇提出的流程方案感兴趣，您有两种方法集成到自己的项目里，一是参照文中的代码，自己实现（核心代码都已在文中，稍作修改即可）; 另一种方法是直接使用封装好的版本，这个项目的名字是 <a href="https://github.com/PrototypeZ/Sq" target="_blank" rel="noopener">Sq</a>, 您只需要把依赖添加到 Gradle，开箱即用。</p>
<p><a href="https://github.com/PrototypeZ/Sq" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/PrototypeZ/Sq/master/sq-logo.png" alt=""></a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>文章很长，感谢您耐心读完。由于本人能力有限，文章可能存在纰漏的地方，欢迎各位指正。关于如何对业务流程进行封装，因为我并没有看到过很多技术文章对这一块进行讨论，所以我个人的见解会有不全面的地方，如果您有更好的方案，欢迎一起讨论。谢谢大家！</p>
</div></article></div></section><footer><div class="paginator"><a href="/2018/09/01/thoughts_in_rxjava/" class="prev">PREV</a><a href="/2018/06/06/using-save-state/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'prototypezs-blog';
var disqus_identifier = '2018/06/25/best-practices-of-android-process-management-2/';
var disqus_title = '如何优雅地构建易维护、可复用的 Android 业务流程(二)';
var disqus_url = 'http://prototypez.github.io/2018/06/25/best-practices-of-android-process-management-2/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//prototypezs-blog.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2018 <a href="http://prototypez.github.io">Prototype Z</a>, unless otherwise noted.</p></div></footer></div><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-76153093-1",'auto');ga('send','pageview');</script><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "//hm.baidu.com/hm.js?0ccb482127338efcdd63fb82acbe28c9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html>