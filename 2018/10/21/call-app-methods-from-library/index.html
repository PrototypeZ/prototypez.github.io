<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 一种在 Library 模块中调用 Application 模块功能的方法 · Prototype Z</title><meta name="description" content="组件化的第一步，模块化"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="https://avatars0.githubusercontent.com/u/18300865?v=3&amp;s=40"><link rel="stylesheet" href="/css/apollo.css"><!--if theme.googlefonts--><!--    link(rel="stylesheet", href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600" type='text/css')--><!--else --><!--    link(rel="stylesheet", href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type='text/css')--></head><body><div id="mask" style="display: none;"><img id="mask-image" src="#" style=" "></div><div class="wrap"><header><a href="/" class="logo-link"><img src="https://avatars0.githubusercontent.com/u/18300865?v=3&amp;s=120"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/kuailederena" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/prototypez" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">一种在 Library 模块中调用 Application 模块功能的方法</h1><div class="post-time">Oct 21, 2018</div><div class="post-content"><p>在<a href="/2018/09/15/app-joint-introduction/">上一篇分享</a>中，我介绍的主题是如何在一个 Android 项目中使用 <a href="https://github.com/PrototypeZ/AppJoint" target="_blank" rel="noopener">AppJoint</a> 进行组件化。有读者找到我说：我知道组件化很美好，但是项目改造总是需要成本的，而且这个成本是我们目前承受不了的，我们目前能做的最多的只能是 <strong>模块化</strong>，即把主 app 模块的功能拆出来，放到新的 <strong>library</strong> 模块里，但目前面临的最直接的问题就是，<strong>拆出来的新模块如何调用主 app 模块里的方法</strong>。能否不用组件化那一整套工具，先用 <strong>最轻量级的方法</strong> 解决这个跨模块方法调用的问题？</p>
<a id="more"></a>
<p>答案当然是肯定的，<a href="https://github.com/PrototypeZ/AppJoint" target="_blank" rel="noopener">AppJoint</a> 就是这样一个轻量级的工具，如果你不想组件化，那么你完全可以把它当成一个只是用来解决跨模块方法调用的问题的小工具。</p>
<h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>假设目前已经从 <strong>app</strong> 模块拆出了一个 <strong>module1</strong> 模块，<strong>app</strong> 模块是主 app 模块， 而 <strong>module1</strong> 模块是 library 模块。如果 <strong>module1</strong> 模块想要调用 <strong>app</strong> 模块的功能，那么肯定需要存在一个接口，这个接口两个模块要都能访问到。所以这个接口存在的位置就只能是 <strong>app</strong> 模块和 <strong>module1</strong> 模块都依赖的公共模块。这里的这个公共模块，它可以是已有的公共模块，也可以是新创建的公共模块。我们在这个公共模块里声明这个接口，即 <strong>app</strong> 模块希望被 <strong>module1</strong> 模块调用的方法的接口：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AppService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// start Activity from app module</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">startActivityOfApp</span><span class="params">(context: <span class="type">Context</span>)</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// get Fragment from app module</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">obtainFragmentOfApp</span><span class="params">()</span></span>: Fragment</span><br><span class="line"></span><br><span class="line">  <span class="comment">// call synchronous method from app module</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">callMethodSyncOfApp</span><span class="params">()</span></span>: String</span><br><span class="line"></span><br><span class="line">  <span class="comment">// call asynchronous method from app module</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">callMethodAsyncOfApp</span><span class="params">(callback: <span class="type">AppCallback</span>&lt;<span class="type">AppEntity</span>&gt;)</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// get RxJava Observable from app module</span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">observableOfApp</span><span class="params">()</span></span>: Observable&lt;AppEntity&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个接口由于处于公共模块，所以两个模块都能访问到这个接口。接下来我们就来解决这个问题，即在 <strong>module1</strong> 模块里调用 <strong>app</strong> 模块的方法。</p>
<h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>在声明上面这个接口以后，我们在 <strong>app</strong> 模块里实现这个接口：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ServiceProvider</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppServiceImpl</span> : <span class="type">AppService &#123;</span></span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">startActivityOfApp</span><span class="params">(context: <span class="type">Context</span>)</span></span> &#123;</span><br><span class="line">    AppActivity.start(context)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">obtainFragmentOfApp</span><span class="params">()</span></span>: Fragment &#123;</span><br><span class="line">    <span class="keyword">return</span> AppFragment.newInstance()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">callMethodSyncOfApp</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"syncMethodResultApp"</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">callMethodAsyncOfApp</span><span class="params">(callback: <span class="type">AppCallback</span>&lt;<span class="type">AppEntity</span>&gt;)</span></span> &#123;</span><br><span class="line">    Thread &#123; callback.onResult(AppEntity(<span class="string">"asyncMethodResultApp"</span>)) &#125;.start()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">observableOfApp</span><span class="params">()</span></span>: Observable&lt;AppEntity&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> Observable.just(AppEntity(<span class="string">"rxJavaResultApp"</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意一点，我们在实现类上标记了 <code>@ServiceProvider</code> 注解。然后我们就可以像下面这样，从 <strong>module1</strong> 模块里调用 <strong>app</strong> 模块里的方法了：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> appService = AppJoint.service(AppService::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// call methods inside AppService</span></span><br><span class="line">appService.callMethodSyncOfApp()</span><br><span class="line">appService.observableOfApp().subscribe()</span><br><span class="line">appService.startActivityOfApp(context)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>即使我们没有引入组件化的任何概念，我们也能轻松解决模块化中最常遇见的跨模块方法调用的这一类问题。</p>
<p>关于如何在项目中引入 <strong>AppJoint</strong>，可以前往 <strong>AppJoint</strong> 的 Github 主页：<a href="https://github.com/PrototypeZ/AppJoint" target="_blank" rel="noopener">https://github.com/PrototypeZ/AppJoint</a>, 核心代码不超过 500 行，您可以使用开箱即用的版本，也可以自行在项目中引入。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>在模块化之后，您可能会对项目的组件化产生兴趣，欢迎继续阅读我的组件化经验分享 <a href="http://prototypez.github.io/2018/09/15/app-joint-introduction/">『回归初心：极简 Android 组件化方案 — AppJoint』</a>，希望可以给您的项目组件化带去一点点帮助，谢谢！ : )</p>
<hr>
<p>如果您对我的技术分享感兴趣，欢迎关注我的个人公众号：麻瓜日记，不定期更新原创技术分享，谢谢！:)</p>
<p><img src="http://prototypez.github.io/images/qrcode.jpg" alt=""></p>
</div></article></div></section><footer><div class="paginator"><a href="/2018/10/10/cross-module-method-invocation-made-easy/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'prototypezs-blog';
var disqus_identifier = '2018/10/21/call-app-methods-from-library/';
var disqus_title = '一种在 Library 模块中调用 Application 模块功能的方法';
var disqus_url = 'http://prototypez.github.io/2018/10/21/call-app-methods-from-library/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//prototypezs-blog.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2018 <a href="http://prototypez.github.io">Prototype Z</a>, unless otherwise noted.</p></div></footer></div><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-76153093-1",'auto');ga('send','pageview');</script><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "//hm.baidu.com/hm.js?0ccb482127338efcdd63fb82acbe28c9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html>