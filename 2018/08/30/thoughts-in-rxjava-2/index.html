<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> RxJava 沉思录（二）：空间维度 · Prototype Z</title><meta name="description" content="重新认真思考 RxJava"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="https://avatars0.githubusercontent.com/u/18300865?v=3&amp;s=40"><link rel="stylesheet" href="/css/apollo.css"><!--if theme.googlefonts--><!--    link(rel="stylesheet", href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600" type='text/css')--><!--else --><!--    link(rel="stylesheet", href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type='text/css')--></head><body><div id="mask" style="display: none;"><img id="mask-image" src="#" style=" "></div><div class="wrap"><header><a href="/" class="logo-link"><img src="https://avatars0.githubusercontent.com/u/18300865?v=3&amp;s=120"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/kuailederena" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/prototypez" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">RxJava 沉思录（二）：空间维度</h1><div class="post-time">Aug 30, 2018</div><div class="post-content"><p>本文是 “RxJava 沉思录” 系列的第二篇分享。本系列所有分享：</p>
<ul>
<li><a href="/2018/08/29/thoughts-in-rxjava-1/">RxJava 沉思录（一）：你认为 RxJava 真的好用吗？</a></li>
<li><a href="/2018/08/30/thoughts-in-rxjava-2/">RxJava 沉思录（二）：空间维度</a></li>
<li><a href="/2018/08/31/thoughts-in-rxjava-3/">RxJava 沉思录（三）：时间维度</a></li>
<li><a href="/2018/09/01/thoughts-in-rxjava-4/">RxJava 沉思录（四）：总结</a></li>
</ul>
<p>在上一篇分享中，我们澄清了目前有关 RxJava 的几个最流行的误解，它们分别是：“<strong>链式编程是 RxJava 的厉害之处</strong>”，“<strong>RxJava 等于异步加简洁</strong>”，“<strong>RxJava 是用来解决 Callback Hell 的</strong>”。在上一篇的最后，我们了解了 RxJava 其实给我们最基础的功能就是帮我们统一了所有异步回调的接口。但是 RxJava 并不止于此，本文我们将首先介绍 <strong>Observable 在空间维度上重新组织事件的能力</strong>。</p>
<a id="more"></a>
<h2 id="从一个简单的例子说起"><a href="#从一个简单的例子说起" class="headerlink" title="从一个简单的例子说起"></a>从一个简单的例子说起</h2><p>情景：有一个相册应用，从网络获取当前用户的照片列表，展示在 RecyclerView 里：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NetworkApi</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GET</span>(<span class="string">"/path/to/api"</span>)</span><br><span class="line">    Call&lt;List&lt;Photo&gt;&gt; getAllPhotos();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面是使用 Retrofit 定义的从网络获取照片的 API 的接口。大家都知道，如果我们使用 Retrofit 的 <strong>RxJavaCallAdapter</strong> 就可以把接口中的返回类型从 <code>Call&lt;List&lt;Photo&gt;&gt;</code> 转为 <code>Observable&lt;List&lt;Photo&gt;&gt;</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NetworkApi</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GET</span>(<span class="string">"/path/to/api"</span>)</span><br><span class="line">    Observable&lt;List&lt;Photo&gt;&gt; getAllPhotos();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么我们使用这个接口展示照片的代码应该长下面这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NetworkApi networkApi = ...</span><br><span class="line">networkApi.getAllPhotos()</span><br><span class="line">    .subscribeOn(Schedulers.io())</span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">    .subscribe(photos -&gt; &#123;</span><br><span class="line">        adapter.setData(photos);</span><br><span class="line">        adapter.notifyDataSetChanged();</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>现在新加一个需求，请求当前用户照片列表这个网络请求，需要加入缓存功能（缓存的是网络响应中的图片的URL，图片的 Bitmap 缓存交给专门的图片加载框架，例如 <strong>Glide</strong>），也就是说，当用户希望展示图片列表时，先去缓存读取用户的照片列表进行加载（如果缓存里有这个接口的上次访问的数据），同时发起网络请求，待网络请求返回之后，更新缓存，同时使用使用最新的返回数据刷新照片列表。如果我们选择使用 <strong>JakeWharton</strong> 的 <a href="https://github.com/JakeWharton/DiskLruCache" target="_blank" rel="noopener">DiskLruCache</a> 作为我们的缓存介质，那么上面的代码将变为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">DiskLruCache cache = ... </span><br><span class="line">DiskLruCache.Snapshot snapshot = cache.get(<span class="string">"getAllPhotos"</span>);</span><br><span class="line"><span class="keyword">if</span> (snapshot != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 读取缓存数据并反序列化</span></span><br><span class="line">    List&lt;Photo&gt; cachedPhotos = <span class="keyword">new</span> Gson().fromJson(</span><br><span class="line">        snapshot.getString(VALUE_INDEX),</span><br><span class="line">        <span class="keyword">new</span> TypeToken&lt;List&lt;Photo&gt;&gt;()&#123;&#125;.getType()</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 刷新照片列表</span></span><br><span class="line">    adapter.setData(photos);</span><br><span class="line">    adapter.notifyDataSetChanged();</span><br><span class="line">&#125;</span><br><span class="line">NetworkApi networkApi = ...</span><br><span class="line">networkApi.getAllPhotos()</span><br><span class="line">    .subscribeOn(Schedulers.io())</span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">    .subscribe(photos -&gt; &#123;</span><br><span class="line">        adapter.setData(photos);</span><br><span class="line">        adapter.notifyDataSetChanged();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新缓存</span></span><br><span class="line">        DiskLruCache.Editor editor = cache.edit(<span class="string">"getAllPhotos"</span>);</span><br><span class="line">        editor.set(VALUE_INDEX, <span class="keyword">new</span> Gson().toJson(photos)).commit();</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>上面的代码就是最直观的可以解决需求的代码，我们进一步思考一下，读取文件缓存也属于耗时操作，我们最好把它封装为异步任务，既然网络请求已经被封装成 <code>Observable</code> 了，我们尝试把读取文件缓存也封装为 <code>Observable</code> :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;List&lt;Photo&gt;&gt; cachedObservable = Observable.create(emitter -&gt; &#123;</span><br><span class="line">    DiskLruCache.Snapshot snapshot = cache.get(<span class="string">"getAllPhotos"</span>);</span><br><span class="line">    <span class="keyword">if</span> (snapshot != <span class="keyword">null</span>) &#123;</span><br><span class="line">        List&lt;Photo&gt; cachedPhotos = <span class="keyword">new</span> Gson().fromJson(</span><br><span class="line">            snapshot.getString(VALUE_INDEX),</span><br><span class="line">            <span class="keyword">new</span> TypeToken&lt;List&lt;Photo&gt;&gt;()&#123;&#125;.getType()</span><br><span class="line">        );</span><br><span class="line">        emitter.onNext(cachedPhotos);</span><br><span class="line">    &#125; </span><br><span class="line">    emitter.onComplete();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>到目前为止，发起网络请求和读取缓存这两个异步操作都被我们封装成了 <code>Observable</code> 的形式，前面做了这么多铺垫，接下来进入正题：把原先的面向 Callback 的异步操作统一改写为 <code>Observable</code> 的形式以后，首先带来的好处就是可以对 <strong>Observable 在空间维度上进行重新组织</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">networkApi.getAllPhotos()</span><br><span class="line">    .doOnNext(photos -&gt; </span><br><span class="line">        <span class="comment">// 更新缓存</span></span><br><span class="line">        cache.edit(<span class="string">"getAllPhotos"</span>)</span><br><span class="line">            .set(VALUE_INDEX, <span class="keyword">new</span> Gson().toJson(photos))</span><br><span class="line">            .commit()</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// 读取现有缓存</span></span><br><span class="line">    .startWith(cachedObservable)</span><br><span class="line">    .subscribeOn(Schedulers.io())</span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">    .subscribe(photos -&gt; &#123;</span><br><span class="line">        adapter.setData(photos);</span><br><span class="line">        adapter.notifyDataSetChanged();</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>调用 <code>startWith</code> 操作符后，会生成一个新的 Observable，新的 <code>Observable</code> 会首先发射传入的 <code>Observable</code> 包含的元素，而后才会发射原来的 <code>Observable</code> 包含的元素。例如 <code>Observable</code> A 包含 a1, a2 两个元素， <code>Observable</code> B 包含 b1, b2 两个元素，那么 b.startWith(a) 返回的新 <code>Observable</code> 发射序列顺序为： a1, a2, b1, b2。—— <a href="http://reactivex.io/documentation/operators/startwith.html" target="_blank" rel="noopener">参考资料：StartWith</a> </p>
</blockquote>
<p>在上面的例子中，我们连接了网络请求和读取缓存这两个 Observable，原先需要分别处理结果的两个异步任务，我们现在把它们结合成了一个，指定了一个观察者就满足了需求。这个观察者会被回调 2 次，第一次是来自缓存的结果，第二次是来自网络的结果，体现在界面上就是列表刷新了两次。</p>
<p>这里引发了我们的思考，原先 Callback 的写法，如果我们有 <strong>n</strong> 个异步任务，我们就需要指定 <strong>n</strong> 个回调；而如果在 <strong>n</strong> 个异步任务都已经被封装成 <code>Observable</code> 的情况下，我们就可以对 <code>Observable</code> 进行分类、组合、变换，经过这样的处理以后，我们的观察者的数量就会减少，而且职责会变的简单而直接，只需要对它所关心的数据类型做出响应，而不需要关心数据从何而来，经历过怎样的变化。</p>
<p>我们再进一步，上面的例子再加一个需求：如果从网络请求回来的数据和缓存中提前响应的数据一致，就不需要再刷新一次了。也就是说，如果缓存数据和网络数据一致，那缓存数据刷新一次列表以后，网络数据不需要再去刷新一次列表了。</p>
<p>我们考虑一下，如果我们使用传统 Callback 的形式，指定了两个 Callback 去处理这个需求，为了保证第二次网络请求回来的相同数据不刷新，我们势必需要在两个 Callback 之外，定义一个变量来保存缓存数据，然后在网络请求的回调内，比较两个值，来决定是否需要刷新界面。</p>
<p>但如果我们用 RxJava 如何来实现这个需求，该如何写呢：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">networkApi.getAllPhotos()</span><br><span class="line">    .doOnNext(photos -&gt; </span><br><span class="line">        cache.edit(<span class="string">"getAllPhotos"</span>)</span><br><span class="line">            .set(VALUE_INDEX, <span class="keyword">new</span> Gson().toJson(photos))</span><br><span class="line">            .commit()</span><br><span class="line">    )</span><br><span class="line">    .startWith(cachedObservable)</span><br><span class="line">    <span class="comment">// 保证不会出现相同数据</span></span><br><span class="line">    .distinctUntilChanged()</span><br><span class="line">    .subscribeOn(Schedulers.io())</span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">    .subscribe(photos -&gt; &#123;</span><br><span class="line">        adapter.setData(photos);</span><br><span class="line">        adapter.notifyDataSetChanged();</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>distinctUntilChanged</code> 操作符用来确保 <code>Observable</code> 发射的元素里，相邻的两个元素必须是不相等的。 <a href="http://reactivex.io/documentation/operators/distinct.html" target="_blank" rel="noopener">参考资料：Distinct</a></p>
</blockquote>
<p>与原先的写法相比，只多了一行 <code>.distinctUntilChanged()</code> ( 我们假设用于比较两个对象是否相等的 <code>equals</code> 方法已经实现 )，就可以满足，在网络数据和缓存数据一致的情况下，观察者只回调一次。</p>
<p>我们比较一下使用 Callback 的写法和使用 <code>Observable</code> 进行组装的写法，可以发现，使用 Callback 的写法，经常会由于需求的变化，导致 Callback 内部的逻辑发生变动，而使用 <code>Observable</code> 的写法，观察者的核心逻辑则较为稳定，很少发生变化（本例中为刷新列表）。<strong>Observable 通过内置的操作符对自身发射的元素在空间维度上重新组织，或者与其他的 <code>Observable</code> 一起在空间维度上进行重新组织，使得观察者的逻辑简单而直接，不需要关心数据从何而来，从而使观察者的逻辑较为稳定</strong>。</p>
<h2 id="一个复杂的例子"><a href="#一个复杂的例子" class="headerlink" title="一个复杂的例子"></a>一个复杂的例子</h2><p>情景：实现一个具有多种类型的 RecyclerView，如图所示：</p>
<p><img src="http://prototypez.github.io/images/complex-list.png" alt=""></p>
<p>假设列表中有 3 种类型的数据，这 3 种类型共同填充了一个 RecyclerView，简单起见，我们定义 Retrofit 接口如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NetworkApi</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GET</span>(<span class="string">"/path/to/api"</span>)</span><br><span class="line">    Observable&lt;List&lt;ItemA&gt;&gt; getItemListOfTypeA();</span><br><span class="line">    <span class="meta">@GET</span>(<span class="string">"/path/to/api"</span>)</span><br><span class="line">    Observable&lt;List&lt;ItemB&gt;&gt; getItemListOfTypeB();</span><br><span class="line">    <span class="meta">@GET</span>(<span class="string">"/path/to/api"</span>)</span><br><span class="line">    Observable&lt;List&lt;ItemC&gt;&gt; getItemListOfTypeC();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到目前为止，情况还是简单的, 我只要维护 3 个 RecyclerView 并分别各自更新即可。但是我们现在接到新加需求，这 3 种类型的数据在列表中出现的顺序是可配置的，而且 3 种类型数据不一定全部需要展示，也就是说可能展示 3 种，也可能只展示其中 2 种。我们定义与之对应的接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NetworkApi</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GET</span>(<span class="string">"/path/to/api"</span>)</span><br><span class="line">    Observable&lt;List&lt;ItemA&gt;&gt; getItemListOfTypeA();</span><br><span class="line">    <span class="meta">@GET</span>(<span class="string">"/path/to/api"</span>)</span><br><span class="line">    Observable&lt;List&lt;ItemB&gt;&gt; getItemListOfTypeB();</span><br><span class="line">    <span class="meta">@GET</span>(<span class="string">"/path/to/api"</span>)</span><br><span class="line">    Observable&lt;List&lt;ItemC&gt;&gt; getItemListOfTypeC();</span><br><span class="line">    <span class="comment">// 需要展示的数据顺序</span></span><br><span class="line">    <span class="meta">@GET</span>(<span class="string">"/path/to/api"</span>)</span><br><span class="line">    Observable&lt;List&lt;String&gt;&gt; getColumns();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新加的 <code>getColumns</code> 接口，返回的数据形如：</p>
<ul>
<li><code>[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</code></li>
<li><code>[&quot;b&quot;, &quot;a&quot;]</code></li>
<li><code>[&quot;b&quot;, &quot;c&quot;]</code></li>
</ul>
<p>首先考虑使用普通的 Callback 形式如何来实现这个需求。由于 3 种数据现在顺序可变，数量也无法确定，如果还是考虑由多个 RecyclerView 来维护的话需要在布局中调用 <code>addView</code>, <code>removeView</code><br>来添加移除 RecyclerView，这样的话性能上不够好，我们考虑把所有数据填充到一个 RecyclerView 中，不同类型的数据通过不同 ItemType 进行区分。下面的代码中我依然使用了 <code>Observable</code> ，只是我仅仅把它当成普通的 Callback 功能使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> NetworkApi networkApi = ...</span><br><span class="line"><span class="comment">// 不同类型数据出现的顺序</span></span><br><span class="line"><span class="keyword">private</span> List&lt;String&gt; resultTypes;</span><br><span class="line"><span class="comment">// 这些类型对应的数据的集合</span></span><br><span class="line"><span class="keyword">private</span> LinkedList&lt;List&lt;? extends Item&gt;&gt; responseList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    networkApi.getColumns().subscribe(columns -&gt; &#123;</span><br><span class="line">        <span class="comment">// 保存配置的栏目顺序</span></span><br><span class="line">        resultTypes = columns;</span><br><span class="line">        responseList = <span class="keyword">new</span> LinkedList&lt;&gt;(Collections.nCopies(columns.size(), <span class="keyword">new</span> ArrayList&lt;&gt;()));</span><br><span class="line">        <span class="keyword">for</span> (String type : columns) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"a"</span>:</span><br><span class="line">                    networkApi.getItemListOfTypeA().subscribe(data -&gt; onOk(<span class="string">"a"</span>, data));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"b"</span>:</span><br><span class="line">                    networkApi.getItemListOfTypeB().subscribe(data -&gt; onOk(<span class="string">"b"</span>, data));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"c"</span>:</span><br><span class="line">                    networkApi.getItemListOfTypeC().subscribe(data -&gt; onOk(<span class="string">"c"</span>, data));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onOk</span><span class="params">(String type, List&lt;? extends Item&gt; response)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 按配置的顺序，更新对应位置上的数据</span></span><br><span class="line">    responseList.set(resultTypes.indexOf(type), response);</span><br><span class="line">    <span class="comment">// 把当前已返回的数据填充到一个 List 中</span></span><br><span class="line">    List&lt;Item&gt; data = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (List&lt;? extends Item&gt; itemList: responseList) &#123;</span><br><span class="line">        data.addAll(itemList);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新列表</span></span><br><span class="line">    adapter.setData(data);</span><br><span class="line">    adapter.notifyDataSetChanged();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码，为了避免 <strong>Callback Hell</strong> 出现，我已经提前把 <code>onOk</code> 提到了外部层次，使代码便于从上往下阅读。但是不知道你有没有和我相同的感觉，就是类似这样的代码总给人一种不是很 “<strong>内聚</strong>” 的感觉，就是为了把 Callback 展平，导致一些中间变量被暴露到了外层空间。</p>
<p>带着这个问题，我们先分析一下数据流动：</p>
<ol>
<li><code>refresh</code> 方法发起第一次请求，得到需要被展示的 <strong>n</strong> 种数据的类型以及顺序。</li>
<li>根据第一次请求的结果，发起 <strong>n</strong> 次请求，分别得到每种数据的结果。</li>
<li><code>onOk</code> 方法作为观察者, 会被回调 <strong>n</strong> 次，按照第一个接口里返回的顺序正确的汇总 <strong>2</strong> 中每个数据接口返回的结果，并且通知界面更新。 </li>
</ol>
<p>有点像写作文一样，这是一种 <strong>总——分——总</strong> 的结构。</p>
<h2 id="Observable-在空间维度重新组织事件"><a href="#Observable-在空间维度重新组织事件" class="headerlink" title="Observable 在空间维度重新组织事件"></a>Observable 在空间维度重新组织事件</h2><p>接下来我们使用 RxJava 来实现这个需求，我们会用到 RxJava 的一些操作符，来对 <code>Observable</code> 进行重新组织：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">NetworkApi networkApi = ...</span><br><span class="line"></span><br><span class="line">networkApi.getColumns()</span><br><span class="line">    .map(types -&gt; &#123;</span><br><span class="line">        List&lt;Observable&lt;? extends List&lt;? extends Item&gt;&gt;&gt; requestObservableList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String type : types) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"a"</span>:</span><br><span class="line">                    requestObservableList.add(</span><br><span class="line">                        networkApi.getItemListOfTypeA().startWith(<span class="keyword">new</span> ArrayList&lt;ItemA&gt;())</span><br><span class="line">                    );</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"b"</span>:</span><br><span class="line">                    requestObservableList.add(</span><br><span class="line">                        networkApi.getItemListOfTypeB().startWith(<span class="keyword">new</span> ArrayList&lt;ItemB&gt;())</span><br><span class="line">                    );</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"c"</span>:</span><br><span class="line">                    requestObservableList.add(</span><br><span class="line">                        networkApi.getItemListOfTypeC().startWith(<span class="keyword">new</span> ArrayList&lt;ItemC&gt;())</span><br><span class="line">                    );</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> requestObservableList;</span><br><span class="line">    &#125;)</span><br><span class="line">    .flatMap(requestObservables -&gt; Observable.combineLatest(requestObservables, objects -&gt; &#123;</span><br><span class="line">        List&lt;Item&gt; items = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Object response : objects) &#123;</span><br><span class="line">            items.addAll((List&lt;? extends Item&gt;) response);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> items;</span><br><span class="line">    &#125;))</span><br><span class="line">    .subscribeOn(Schedulers.io())</span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">    .subscribe(data -&gt; &#123;</span><br><span class="line">        adapter.setData(data);</span><br><span class="line">        adapter.notifyDataSetChanged();</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>我们一步一步分析 RxJava 处理的具体步骤。首先是第一步，获取需要展示的栏目列表，这是最简单的，<code>networkApi.getColumns()</code> 这个方法返回是一个只发射一个元素的 <code>Observable</code>，这个元素即为展示的栏目列表，为了方便后续讨论，假设栏目的顺序为 <code>[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</code>, 如下图所示：</p>
<p><img src="http://prototypez.github.io/images/rxjava-demo-1.png" alt=""></p>
<p>接下来的操作符是 <code>map</code> 操作符，原来的 <code>Observable</code> 进行了变换，变成了一个新的 <code>Observable</code>，新的 <code>Observable</code> 还是只发射一个元素，这个元素的类型还是 List ，只不过 List 内部的数据类型从原先的字符串（代表数据类型）变成了 <code>Observable</code>。<code>Observable</code> 发射的元素还可以是 “<code>Observable</code> 的 List ” 吗？是的，没有什么不可以 : ) </p>
<p><img src="http://prototypez.github.io/images/rxjava-demo-2.png" alt=""></p>
<blockquote>
<p><code>map</code> 操作符负责把一个 <code>Observable</code> 里发射的元素全部进行转换，生成一个发射新的元素的 <code>Observable</code>，元素的种类会发生改变，但是发射的元素的数量不会发生改变。 <a href="http://reactivex.io/documentation/operators/map.html" target="_blank" rel="noopener">参考资料：Map</a></p>
</blockquote>
<p>这个操作，在业务上的含义是，根据上一步取回的栏目列表，即 <code>[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</code>，根据不同的数据类型，分别发起请求去获取对应栏目的数据列表，例如栏目类型是 <code>a</code> 的话，就对应发起 <code>networkApi.getItemListOfTypeA()</code> 请求。这里有一点值得注意，就是每一个具体的请求后面都跟了一个 <code>.startWith(new ArrayList&lt;&gt;())</code>，也就是说每个具体请求栏目内容的 <code>Observable</code> 在返回真正的数据 List 之前都会返回一个空的 List ，这里这么处理的原因我们会在下一步中解释。</p>
<p>接下来这一步可能是最难理解的一步了，<code>map</code> 操作之后，紧接着是 <code>flatMap</code> 操作符，而 <code>flatMap</code> 操作符传入的 lambda 表达式内部，又调用了 <code>Observable.combineLatest</code> 操作符，我们先从里面的 <code>combineLatest</code> 操作符开始讲起，请看下图：</p>
<p><img src="http://prototypez.github.io/images/rxjava-demo-3.png" alt=""></p>
<p><code>combineLatest</code> 操作符的第一个参数 <code>requestObservables</code>，它的类型是 <code>Observable</code> 的 List，它就是上一步中 <code>map</code> 操作符进行变换之后，新的 <code>Observable</code> 发射的数据，即由</p>
<ul>
<li><code>networkApi.getItemListOfTypeA().startWith(...)</code></li>
<li><code>networkApi.getItemListOfTypeB().startWith(...)</code></li>
<li><code>networkApi.getItemListOfTypeC().startWith(...)</code></li>
</ul>
<p>3 个 <code>Observable</code> 组成的 List。</p>
<p><code>combineLatest</code> 操作符的第二个参数是个 lambda 表达式，这个 lambda 表达式的参数类型是 <code>Object[]</code>，这个数组的长度等于 <code>requestObservables</code> 的长度，<code>Object[]</code> 数组中每个元素即为 <code>requestObservables</code> 中每个 <code>Observable</code> 发射的元素，即：</p>
<ul>
<li><code>Object[0]</code> 对应 <code>requestObservables[0]</code> 发射的元素</li>
<li><code>Object[1]</code> 对应 <code>requestObservables[1]</code> 发射的元素</li>
<li><code>Object[2]</code> 对应 <code>requestObservables[2]</code> 发射的元素</li>
</ul>
<p>那这个 lambda 表达式被调用的时机是什么时候呢？当 <code>requestObservables</code> 中任意一个 <code>Observable</code> 发射一个元素时，这个元素便会和 <code>requestObservables</code> 中剩余的所有 <code>Observable</code> <strong>最近一次</strong> 发射的元素一起，作为参数调用这个 lambda 表达式。</p>
<p>那么整个 <code>combineLatest</code> 操作符的作用就是，返回一个新的 <code>Observable</code>, 根据第一个参数里输入的一组 <code>Obsevable</code>，按照上面说的时机，调用第二个参数里的那个 lambda 表达式，把这个 lambda 表达式的返回值，作为新的 <code>Observable</code> 发射的值，lambda 被调用几次，就发射几个元素。</p>
<blockquote>
<p><a href="http://reactivex.io/documentation/operators/combinelatest.html" target="_blank" rel="noopener">参考资料：CombineLatest</a></p>
</blockquote>
<p>我们这里 lambda 表达式内部的逻辑比较简单，就是把 3 个接口里返回的数据进行汇总，组成一个新的 List 。我们再回过头看上面那张图，我们可以看到，<code>Observable.combinLatest</code> 返回的新的 <code>Observable</code> 一共发射了 4 个元素，它们分别是：</p>
<ul>
<li><code>[]</code></li>
<li><code>[{ItemB}, {ItemB}, ...]</code></li>
<li><code>[{ItemA}, {ItemA}, ..., {ItemB}, {ItemB}, ...]</code></li>
<li><code>[{ItemA}, {ItemA}, ..., {ItemB}, {ItemB}, ..., {ItemC}, {ItemC}, ...]</code></li>
</ul>
<p>前面留了一个问题没有解释，为什么 3 个获取具体的栏目数据的接口需要调用 <code>startWith</code> 操作符发射一个空白列表，就像这样：<code>networkApi.getItemListOfTypeA().startWith(...)</code>，现在这个答案应该清晰了，如果不调用这个操作符，那么 <code>combineLatest</code> 操作符生成的新 <code>Observable</code> 将会只发射一个元素, 即上面 4 个元素的最后一个，从用户的感受来看，必须要等所有栏目全部请求成功以后才会一次性展示，而不是渐进地展示。</p>
<p>说完了内部的 <code>combineLatest</code> 操作符，现在该说外层的 <code>flatMap</code> 操作符了，<code>flatMap</code> 操作符也会生成一个新的 <code>Observable</code>，它会通过传入的 lambda 表达式，把旧的 <code>Observable</code> 里发射的每一个元素都映射成一个 <code>Observable</code>，然后把这些 <code>Observable</code> 发射的所有元素作为新的 <code>Observable</code> 发射的元素。</p>
<blockquote>
<p><a href="http://reactivex.io/documentation/operators/flatmap.html" target="_blank" rel="noopener">参考资料：FlatMap</a></p>
</blockquote>
<p>由于我们这里的情况，调用 <code>flatMap</code> 之前的 <code>Observable</code> 只发射了一个元素，所以 <code>flatMap</code> 之后生成的新 <code>Observable</code> 发射的元素，就是 <code>flatMap</code> 操作符传入的那个 lambda 表达式执行完生成的那个 <code>Observable</code> 所发射的元素，也就是说 <code>flatMap</code> 操作符执行完后的那个新的 <code>Observable</code> 发射的元素，和我们刚刚讨论的 <code>combineLatest</code> 操作符执行完后的 <code>Observable</code> 发射的元素是一致的。</p>
<p>到这里为止，RxJava 实现的版本的每一步我们都解释完了，我们回过头重新梳理一下 RxJava 对 <code>Observable</code> 进行变换的过程，如下图：</p>
<p><img src="http://prototypez.github.io/images/rxjava-demo-4.png" alt=""></p>
<p>通过 RxJava 的操作符，我们把 <code>networkApi</code> 里的 4 个接口返回的 4 个 <code>Observable</code>，<strong>在空间维度进行了重新组织</strong>，最终把它们转成了一个 <code>Observable</code>，这个 <code>Observable</code> 发射的元素类型是 <code>List&lt;Item&gt;</code>，而这正是我们的观察者 – Adapter 所关心的数据类型，观察者只需要监听这个 <code>Observable</code> ，并更新数据即可。</p>
<p>我们在讲 RxJava 实现的这个版本之前的时候，说到过 Callback 实现的版本不够 <strong>内聚</strong>，比较一下现在这个 RxJava 的版本，确实可以发现的确 RxJava 这个版本更内聚。但是并非 Callback 版本没有办法做到更内聚，我们可以把 Callback 版本里的 <code>onOk</code>, <code>refresh</code>，<code>resultTypes</code>, <code>responseList</code> 这几个方法和字段封装到一个对象中，对外只暴露 <code>refresh</code> 方法和一个设置观察者的方法，也可以做到一样的内聚，但是这就需要额外的工作量了。可如果我们使用 RxJava 就不一样了，它提供了一堆现成的操作符，通过 <code>Observable</code> 之间的变换与重组，直接就可以写出内聚的代码。</p>
<p>在上面代码里出现的所有操作符中，最核心的一个操作符就是 <code>combineLatest</code> 操作符，仔细比较 RxJava 版本和 Callback 版本就可以发现，<code>combineLatest</code> 操作符的功能其实和 Callback 版本里的 <code>onOk</code> 方法前半部分, <code>resultTypes</code>, <code>responseList</code> 合在一起功能是相当的，一方面负责收集多个接口返回的数据，另一方面保证收集回来的数据的顺序是和上一个接口返回的应该展示的数据的顺序是一致的。 </p>
<h2 id="一种更加函数式的写法"><a href="#一种更加函数式的写法" class="headerlink" title="一种更加函数式的写法"></a>一种更加函数式的写法</h2><p>从代码量上来看，RxJava 版本与 Callback 版本相差无几，对函数式编程比较擅长的人来说，RxJava 版本里 <code>for</code> 循环的写法，不够 “<strong>函数式</strong>”，我们可以把原来的写法改成一种更紧凑、更函数式的写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">NetworkApi networkApi = ...</span><br><span class="line"></span><br><span class="line">netWorkApi.getColumns()</span><br><span class="line">    .flatMap(types -&gt; Observable.fromIterable(types)</span><br><span class="line">        .map(type -&gt; &#123;</span><br><span class="line">            <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"a"</span>: <span class="keyword">return</span> netWorkApi.getItemListOfTypeA().startWith(<span class="keyword">new</span> ArrayList&lt;ItemA&gt;());</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"b"</span>: <span class="keyword">return</span> netWorkApi.getItemListOfTypeB().startWith(<span class="keyword">new</span> ArrayList&lt;ItemB&gt;());</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"c"</span>: <span class="keyword">return</span> netWorkApi.getItemListOfTypeC().startWith(<span class="keyword">new</span> ArrayList&lt;ItemC&gt;());</span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .&lt;List&lt;Observable&lt;? extends List&lt;? extends Item&gt;&gt;&gt;&gt;collectInto(<span class="keyword">new</span> ArrayList&lt;&gt;(), List::add)</span><br><span class="line">        .toObservable()</span><br><span class="line">    )</span><br><span class="line">    .flatMap(requestObservables -&gt; Observable.combineLates(requestObservables, objects -&gt; objects))</span><br><span class="line">    .flatMap(objects -&gt; Observable.fromArray(objects)</span><br><span class="line">        .&lt;List&lt;Item&gt;&gt;collectInto(<span class="keyword">new</span> ArrayList&lt;&gt;(), (items, o) -&gt; items.addAll((List&lt;Item&gt;) o))</span><br><span class="line">        .toObservable()</span><br><span class="line">    )</span><br><span class="line">    .subscribeOn(Schedulers.io())</span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">    .subscribe(data -&gt; &#123;</span><br><span class="line">        adapter.setData(data);</span><br><span class="line">        adapter.notifyDataSetChanged();</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里引入了一个新的操作符 <code>collectInto</code>，用于把一个 <code>Observable</code> 里面发射的元素，收集到一个可变的容器内部，本例中用它来替换 <code>for</code> 循环相关逻辑，具体内容这里不再详细展开。<br><a href="http://reactivex.io/documentation/operators/reduce.html" target="_blank" rel="noopener">参考资料：CollectInto</a></p>
</blockquote>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>第二个例子花了这么大篇幅来讲，超出了我一开始的预期，这也可以看出来的确 RxJava <strong>学习的曲线是陡峭的</strong>，不过我认为这个例子很好的表达我这一小节要阐述的观点，即 <strong>Observable 在空间维度上对事件的重新组织，让我们的事件驱动型编程更具想象力</strong> ，因为原先的编程中，我们面对多少个异步任务，就会写多少个回调，如果任务之间有依赖关系，我们的做法就是修改观察者（回调函数）逻辑以及新增数据结构保证依赖关系，RxJava 给我们带来的新思路是，<code>Observable</code> 的事件在到达观察者之前，可以先通过操作符进行一系列变换（当然变换的规则还是和具体业务逻辑有关的），对观察者屏蔽数据产生的复杂性，只提供给观察者简单的数据接口。</p>
<p>那么是否在这个例子中，是否 RxJava 的版本更好呢，我个人的观点是虽然 RxJava 版本展现了其更有想象力的编程方式，但是就这个具体的例子，<strong>两者并没有太大的差距</strong>。RxJava 可以写出更短更内聚的代码，但是编写和理解的难度较大；Callback 版本虽然朴实无华，但是便于编写以及理解，可维护性更好。对于两者的好坏，我们也不要过于着急下结论，不妨继续看看 RxJava 还有什么其他的优势。</p>
<p>（未完待续）</p>
<p>本文属于 “RxJava 沉思录” 系列，欢迎阅读本系列的其他分享：</p>
<ul>
<li><a href="/2018/08/29/thoughts-in-rxjava-1/">RxJava 沉思录（一）：你认为 RxJava 真的好用吗？</a></li>
<li><a href="/2018/08/30/thoughts-in-rxjava-2/">RxJava 沉思录（二）：空间维度</a></li>
<li><a href="/2018/08/31/thoughts-in-rxjava-3/">RxJava 沉思录（三）：时间维度</a></li>
<li><a href="/2018/09/01/thoughts-in-rxjava-4/">RxJava 沉思录（四）：总结</a></li>
</ul>
<hr>
<p>如果您对我的技术分享感兴趣，欢迎关注我的个人公众号：麻瓜日记，不定期更新原创技术分享，谢谢！:)</p>
<p><img src="http://prototypez.github.io/images/qrcode.jpg" alt=""></p>
</div></article></div></section><footer><div class="paginator"><a href="/2018/08/31/thoughts-in-rxjava-3/" class="prev">PREV</a><a href="/2018/08/29/thoughts-in-rxjava-1/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'prototypezs-blog';
var disqus_identifier = '2018/08/30/thoughts-in-rxjava-2/';
var disqus_title = 'RxJava 沉思录（二）：空间维度';
var disqus_url = 'http://prototypez.github.io/2018/08/30/thoughts-in-rxjava-2/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//prototypezs-blog.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2018 <a href="http://prototypez.github.io">Prototype Z</a>, unless otherwise noted.</p></div></footer></div><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-76153093-1",'auto');ga('send','pageview');</script><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "//hm.baidu.com/hm.js?0ccb482127338efcdd63fb82acbe28c9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html>