<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Prototype Z</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="https://avatars0.githubusercontent.com/u/18300865?v=3&amp;s=40"><link rel="stylesheet" href="/css/apollo.css"><!--if theme.googlefonts--><!--    link(rel="stylesheet", href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600" type='text/css')--><!--else --><!--    link(rel="stylesheet", href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type='text/css')--></head><body><div id="mask" style="display: none;"><img id="mask-image" src="#" style=" "></div><div class="wrap"><header><a href="/" class="logo-link"><img src="https://avatars0.githubusercontent.com/u/18300865?v=3&amp;s=120"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link active">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/kuailederena" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/prototypez" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/10/10/cross-module-method-invocation-made-easy/" class="post-title-link">Cross module method invocation made easy</a></h2><div class="post-time">Oct 10, 2018</div><div class="post-content"><p>Are you building an Android App with multiple modules? If so, I guess you maybe facing the same problem as me, that is: <strong>Cross Module Method Invocation</strong>. It’s easy to call methods from library modules in our application module. But it’s annoying to invoke methods from the application module in our libray modules. </p></div><a href="/2018/10/10/cross-module-method-invocation-made-easy/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/09/15/app-joint-introduction/" class="post-title-link">回归初心：极简 Android 组件化方案 — AppJoint</a></h2><div class="post-time">Sep 15, 2018</div><div class="post-content"><p>Android 组件化的概念大概从两年前开始有人讨论，到目前为止，技术已经慢慢沉淀下来，越来越多团队开源了自己组件化框架。本人所在团队从去年开始调研组件化框架，在了解社区众多组件化方案之后，决定自研组件化方案。为什么明明已经有很多轮子可以用了，却还是决定要自己造个新轮子呢？</p></div><a href="/2018/09/15/app-joint-introduction/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/09/01/thoughts-in-rxjava-4/" class="post-title-link">RxJava 沉思录（四）：总结</a></h2><div class="post-time">Sep 1, 2018</div><div class="post-content"><p>本文是 “RxJava 沉思录” 系列的最后一篇分享。本系列所有分享：</p>
<ul>
<li><a href="/2018/08/29/thoughts-in-rxjava-1/">RxJava 沉思录（一）：你认为 RxJava 真的好用吗？</a></li>
<li><a href="/2018/08/30/thoughts-in-rxjava-2/">RxJava 沉思录（二）：空间维度</a></li>
<li><a href="/2018/08/31/thoughts-in-rxjava-3/">RxJava 沉思录（三）：时间维度</a></li>
<li><a href="/2018/09/01/thoughts-in-rxjava-4/">RxJava 沉思录（四）：总结</a></li>
</ul>
<p>我们在本系列开篇中，曾经留了一个问题：RxJava 是否可以让我们的代码更简洁？作为本系列的最后一篇分享，我们将详细地探讨这个问题。承接前面两篇 “时间维度” 和 “空间维度” 的探讨，我们首先从 <strong>RxJava 的维度</strong> 开始说起。</p></div><a href="/2018/09/01/thoughts-in-rxjava-4/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/08/31/thoughts-in-rxjava-3/" class="post-title-link">RxJava 沉思录（三）：时间维度</a></h2><div class="post-time">Aug 31, 2018</div><div class="post-content"><p>本文是 “RxJava 沉思录” 系列的第三篇分享。本系列所有分享：</p>
<ul>
<li><a href="/2018/08/29/thoughts-in-rxjava-1/">RxJava 沉思录（一）：你认为 RxJava 真的好用吗？</a></li>
<li><a href="/2018/08/30/thoughts-in-rxjava-2/">RxJava 沉思录（二）：空间维度</a></li>
<li><a href="/2018/08/31/thoughts-in-rxjava-3/">RxJava 沉思录（三）：时间维度</a></li>
<li><a href="/2018/09/01/thoughts-in-rxjava-4/">RxJava 沉思录（四）：总结</a></li>
</ul>
<p>在上一篇分享中，我们应该已经对 <strong>Observable 在空间维度上重新组织事件的能力</strong> 印象深刻了，那么自然而然的，我们容易联想到时间维度，事实上就我个人而言，我认为 <strong>Observable 在时间维度上的重新组织事件的能力</strong> 相比较其空间维度的能力更为突出。与上一篇类似，本文接下来将通过列举真实的例子来阐述这一论点。</p></div><a href="/2018/08/31/thoughts-in-rxjava-3/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/08/30/thoughts-in-rxjava-2/" class="post-title-link">RxJava 沉思录（二）：空间维度</a></h2><div class="post-time">Aug 30, 2018</div><div class="post-content"><p>本文是 “RxJava 沉思录” 系列的第二篇分享。本系列所有分享：</p>
<ul>
<li><a href="/2018/08/29/thoughts-in-rxjava-1/">RxJava 沉思录（一）：你认为 RxJava 真的好用吗？</a></li>
<li><a href="/2018/08/30/thoughts-in-rxjava-2/">RxJava 沉思录（二）：空间维度</a></li>
<li><a href="/2018/08/31/thoughts-in-rxjava-3/">RxJava 沉思录（三）：时间维度</a></li>
<li><a href="/2018/09/01/thoughts-in-rxjava-4/">RxJava 沉思录（四）：总结</a></li>
</ul>
<p>在上一篇分享中，我们澄清了目前有关 RxJava 的几个最流行的误解，它们分别是：“<strong>链式编程是 RxJava 的厉害之处</strong>”，“<strong>RxJava 等于异步加简洁</strong>”，“<strong>RxJava 是用来解决 Callback Hell 的</strong>”。在上一篇的最后，我们了解了 RxJava 其实给我们最基础的功能就是帮我们统一了所有异步回调的接口。但是 RxJava 并不止于此，本文我们将首先介绍 <strong>Observable 在空间维度上重新组织事件的能力</strong>。</p></div><a href="/2018/08/30/thoughts-in-rxjava-2/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/08/29/thoughts-in-rxjava-1/" class="post-title-link">RxJava 沉思录（一）：你认为 RxJava 真的好用吗？</a></h2><div class="post-time">Aug 29, 2018</div><div class="post-content"><p>本人两年前第一次接触 RxJava，和大多数初学者一样，看的第一篇 RxJava 入门文章是扔物线写的<a href="https://gank.io/post/560e15be2dca930e00da1083#toc_31" target="_blank" rel="noopener">《给 Android 开发者的 RxJava 详解》</a>，这篇文章流传之广，相信几乎所有学习 RxJava 的开发者都阅读过。尽管那篇文章定位读者是 RxJava 入门的初学者，但是阅读完之后还是觉得懵懵懂懂，总感觉依然不是很理解这个框架设计理念以及优势。</p></div><a href="/2018/08/29/thoughts-in-rxjava-1/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/06/25/best-practices-of-android-process-management-2/" class="post-title-link">如何优雅地构建易维护、可复用的 Android 业务流程(二)</a></h2><div class="post-time">Jun 25, 2018</div><div class="post-content"><p>这是关于如何在 Android 中封装业务流程经验分享的第二篇，第一篇在<a href="http://prototypez.github.io/2018/04/30/best-practices-of-android-process-management/">这里</a>。所谓 <strong>业务流程</strong> ，指的是一系列页面的集合，这些页面肩负着一个特定职责，负责和用户交互，从用户端收集信息。业务流程有时候由用户主动触发，而有时候是由于某些条件不满足而触发，当流程完成以后，有时候只是简单地回到发起流程的页面，用流程的结果更新那个页面；而有时候是继续之前 <strong>由于触发流程而中断</strong> 的操作；还有些时候是则是转入新的流程。</p></div><a href="/2018/06/25/best-practices-of-android-process-management-2/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/06/06/using-save-state/" class="post-title-link">不需要再手写 onSaveInstanceState 了，因为你的时间非常值钱</a></h2><div class="post-time">Jun 6, 2018</div><div class="post-content"><p>如果你是一个有经验的 Android 程序员，那么你肯定手写过许多 <code>onSaveInstanceState</code> 以及 <code>onRestoreInstanceState</code> 方法用来保持 Activity 的状态，因为 Activity 在变为不可见以后，系统随时可能把它回收用来释放内存。<strong>重写 Activity 中的  <code>onSaveInstanceState</code> 方法</strong> 是 Google 推荐的用来保持 Activity 状态的做法。<br></div><a href="/2018/06/06/using-save-state/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/04/30/best-practices-of-android-process-management/" class="post-title-link">如何优雅地构建易维护、可复用的 Android 业务流程</a></h2><div class="post-time">Apr 30, 2018</div><div class="post-content"><p>有一定实际 Android 项目开发经验的人，一定曾经在项目中处理过很多重复的业务流程。例如开发一个社交 App ，那么出于用户体验考虑，会需要允许匿名用户（不登录的用户）可以浏览信息流的内容（或者只能浏览受限的内容），当用户想要进一步操作（例如点赞）时，提示用户需要登录或者注册，用户完成这个流程才可以继续刚刚的操作。而如果用户需要进行更深入的互动（例如评论，发布状态），则需要实名认证或者补充手机号这样的流程完成才可以继续操作。</p></div><a href="/2018/04/30/best-practices-of-android-process-management/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/05/16/root-and-install-Xposed-framework-on-XiaoMi4-with-Android-M/" class="post-title-link">小米4 Android 6.0 版本 Root 并安装 Xposed 框架攻略</a></h2><div class="post-time">May 16, 2016</div><div class="post-content"><p>本人自 Android 开发入坑一周年以来，向来对Root设备不太感冒。我对Root的设备的态度和对苹果的越狱差不多。大学期间有个舍友越狱了自己的 iPhone，据说从此可以下载许多的收费应用和游戏，所以越狱给我的映像就是破解软件的收费限制，Root也差不多。自己成为一名开发者之后，深感 Google 大法好，不 Root 也能把 Android 玩得很好，然而我毕竟还是 too young too simple，在微信群的抢红包大战中败给越狱之后的 iPhone 的抢红包插件之后，我决定研究 Android 上的抢红包插件。</p></div><a href="/2016/05/16/root-and-install-Xposed-framework-on-XiaoMi4-with-Android-M/" class="read-more">...more</a></article></li></ul></section><footer><div class="paginator"><a href="/page/2/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2018 <a href="http://prototypez.github.io">Prototype Z</a>, unless otherwise noted.</p></div></footer></div><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-76153093-1",'auto');ga('send','pageview');</script><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "//hm.baidu.com/hm.js?0ccb482127338efcdd63fb82acbe28c9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html>